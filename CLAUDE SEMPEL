//+------------------------------------------------------------------+
//|                                               GeminiKuBreak.mq5    |
//|                                                         Gemini AI  |
//|                                             https://www.google.com |
//+------------------------------------------------------------------+
#property copyright "Gemini AI"
#property link      "https://www.google.com"
#property version   "1.00"

// Include required MQL5 files
#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh>

// Define custom object constants
#define CUSTOM_TEXT_UP    "\x25B2"  // Up arrow
#define CUSTOM_TEXT_DOWN  "\x25BC"  // Down arrow

//--- Enum Declarations
enum ENUM_DONCHIAN_PERIOD_ADAPTATION {
    DONCHIAN_NONE,         // No Period Adaptation
    DONCHIAN_ATR_ADAPTIVE  // ATR-based Adaptation
};

enum ENUM_BREAKOUT_CANDLE_PATTERN {
    ANY_BULLISH,          // Any Bullish Pattern
    ANY_BEARISH,          // Any Bearish Pattern
    ENGULFING_BULLISH,    // Bullish Engulfing
    ENGULFING_BEARISH,    // Bearish Engulfing
    MARUBOZU_BULLISH,     // Bullish Marubozu
    MARUBOZU_BEARISH,     // Bearish Marubozu
    CUSTOM_PATTERN        // Custom Pattern
};

enum ENUM_TIME_BASED_EXIT_DURATION {
    HOURS_1,              // 1 Hour
    HOURS_2,              // 2 Hours
    HOURS_4,              // 4 Hours
    HOURS_8,              // 8 Hours
    HOURS_12,             // 12 Hours
    HOURS_24,             // 24 Hours
    CUSTOM_HOURS          // Custom Hours
};

enum ENUM_POSITION_SIZE_TYPE {
    FIXED_LOT,           // Fixed Lot Size
    RISK_PERCENTAGE      // Risk Percentage
};

//--- Input Parameters
input group "Timeframe Settings"
input ENUM_TIMEFRAMES InpHighTimeframe = PERIOD_D1;     // Analysis Timeframe
input ENUM_TIMEFRAMES InpLowTimeframe = PERIOD_M5;      // Execution Timeframe

input group "Donchian Channel Settings"
input ENUM_DONCHIAN_PERIOD_ADAPTATION InpDonchianAdaptation = DONCHIAN_ATR_ADAPTIVE; // Donchian Adaptation
input int InpDonchianAtrPeriod = 14;                    // ATR Period for Adaptation
input double InpDonchianMultiplier = 1.0;               // Donchian Multiplier

input group "Breakout Pattern Settings"
input ENUM_BREAKOUT_CANDLE_PATTERN InpBuyPattern = ANY_BULLISH;    // Buy Pattern
input ENUM_BREAKOUT_CANDLE_PATTERN InpSellPattern = ANY_BEARISH;   // Sell Pattern

input group "Volume Settings"
input bool InpUseVolumeFilter = false;                  // Use Volume Filter
input int InpVolumeAvgPeriod = 20;                     // Volume Average Period

input group "Stop Loss Settings"
input bool InpUseAtrSL = true;                         // Use ATR Stop Loss
input int InpAtrSlPeriod = 14;                         // ATR SL Period
input double InpAtrSlMultiplier = 2.0;                 // ATR SL Multiplier
input bool InpUseFixedSL = false;                      // Use Fixed Stop Loss
input int InpFixedSLPips = 20;                         // Fixed SL in Pips

input group "Take Profit Settings"
input bool InpUseAtrTP = false;                        // Use ATR Take Profit
input int InpAtrTpPeriod = 14;                         // ATR TP Period
input double InpAtrTpMultiplier = 3.0;                 // ATR TP Multiplier
input bool InpUseFixedTP = false;                      // Use Fixed Take Profit
input int InpFixedTPPips = 50;                         // Fixed TP in Pips

input group "Position Sizing"
input ENUM_POSITION_SIZE_TYPE InpPositionSizeType = RISK_PERCENTAGE; // Position Size Type
input double InpRiskPercent = 1.0;                     // Risk Percentage
input double InpFixedLotSize = 0.1;                    // Fixed Lot Size

input group "Expert Settings"
input int InpMagicNumber = 123456;                     // Magic Number
input string InpTradeComment = "GeminiBreakout";       // Trade Comment

//--- Global Variables
CTrade trade;                   // Trading object
CSymbolInfo symbolInfo;        // Symbol information object
datetime lastBarTime = 0;      // Last processed bar time
int donchianHandle = INVALID_HANDLE;  // Donchian indicator handle
int atrHandle = INVALID_HANDLE;       // ATR indicator handle
//+------------------------------------------------------------------+
//| Custom Indicator Handles and Buffers                              |
//+------------------------------------------------------------------+
double donchianUpperBuffer[];
double donchianLowerBuffer[];
double atrBuffer[];

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit() {
    // Initialize trading object
    trade.SetExpertMagicNumber(InpMagicNumber);
    trade.SetMarginMode();
    trade.SetTypeFillingBySymbol(Symbol());
    trade.SetDeviationInPoints(10); // Slippage

    // Initialize symbol info object
    if(!symbolInfo.Name(Symbol())) {
        Print("Failed to initialize symbol info");
        return INIT_FAILED;
    }

    // Create indicator handles
    donchianHandle = iCustom(Symbol(), InpHighTimeframe, "Custom/Donchian", 
                           20); // Default period, will be adapted
    
    if(donchianHandle == INVALID_HANDLE) {
        Print("Failed to create Donchian Channels indicator");
        return INIT_FAILED;
    }

    atrHandle = iATR(Symbol(), InpHighTimeframe, InpDonchianAtrPeriod);
    if(atrHandle == INVALID_HANDLE) {
        Print("Failed to create ATR indicator");
        return INIT_FAILED;
    }

    // Allocate arrays for indicator buffers
    ArraySetAsSeries(donchianUpperBuffer, true);
    ArraySetAsSeries(donchianLowerBuffer, true);
    ArraySetAsSeries(atrBuffer, true);

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // Release indicator handles
    if(donchianHandle != INVALID_HANDLE) IndicatorRelease(donchianHandle);
    if(atrHandle != INVALID_HANDLE) IndicatorRelease(atrHandle);
    
    // Clean up chart objects
    ObjectsDeleteAll(0, "GeminiBreakout");
    
    Comment(""); // Clear comments
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick() {
    // Check for new bar
    if(!IsNewBar()) return;
    
    // Update indicators
    if(!UpdateIndicators()) {
        Print("Failed to update indicators");
        return;
    }
    
    // Check for open positions
    if(PositionsTotal() > 0) {
        ManageOpenPositions();
        return;
    }
    
    // Check for trading conditions
    CheckForTradingSignals();
}

//+------------------------------------------------------------------+
//| Check if we have a new bar                                        |
//+------------------------------------------------------------------+
bool IsNewBar() {
    static datetime lastBar = 0;
    datetime currentBar = iTime(Symbol(), InpLowTimeframe, 0);
    
    if(lastBar != currentBar) {
        lastBar = currentBar;
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Update indicator values                                           |
//+------------------------------------------------------------------+
bool UpdateIndicators() {
    // Copy Donchian Channel values
    if(CopyBuffer(donchianHandle, 0, 0, 2, donchianUpperBuffer) < 2) return false;
    if(CopyBuffer(donchianHandle, 1, 0, 2, donchianLowerBuffer) < 2) return false;
    
    // Copy ATR values
    if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer) < 1) return false;
    
    return true;
}

//+------------------------------------------------------------------+
//| Check for trading signals                                         |
//+------------------------------------------------------------------+
void CheckForTradingSignals() {
    // Get current candle data
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(Symbol(), InpLowTimeframe, 0, 2, rates) != 2) return;
    
    bool buySignal = false;
    bool sellSignal = false;
    
    // Check buy conditions
    if(rates[0].close > donchianUpperBuffer[0] && 
       IsValidPattern(rates[0], rates[1], InpBuyPattern)) {
        buySignal = true;
        if(InpUseVolumeFilter) {
            buySignal = IsVolumeValid(rates[0].tick_volume);
        }
    }
    
    // Check sell conditions
    if(rates[0].close < donchianLowerBuffer[0] && 
       IsValidPattern(rates[0], rates[1], InpSellPattern)) {
        sellSignal = true;
        if(InpUseVolumeFilter) {
            sellSignal = IsVolumeValid(rates[0].tick_volume);
        }
    }
    
    // Execute trades if signals are valid
    if(buySignal) ExecuteOrder(ORDER_TYPE_BUY);
    if(sellSignal) ExecuteOrder(ORDER_TYPE_SELL);
}
//+------------------------------------------------------------------+
//| Execute trading order                                             |
//+------------------------------------------------------------------+
void ExecuteOrder(ENUM_ORDER_TYPE orderType) {
    double volume = CalculatePositionSize(orderType);
    if(volume <= 0) {
        Print("Invalid position size calculated");
        return;
    }
    
    double entryPrice = (orderType == ORDER_TYPE_BUY) ? 
                        symbolInfo.Ask() : symbolInfo.Bid();
    
    double stopLoss = CalculateStopLoss(orderType, entryPrice);
    double takeProfit = CalculateTakeProfit(orderType, entryPrice, stopLoss);
    
    // Set trade parameters
    trade.SetExpertMagicNumber(InpMagicNumber);
    trade.SetDeviationInPoints(10);
    
    // Execute the trade
    bool result = false;
    if(orderType == ORDER_TYPE_BUY) {
        result = trade.Buy(volume, Symbol(), entryPrice, stopLoss, takeProfit, InpTradeComment);
    } else {
        result = trade.Sell(volume, Symbol(), entryPrice, stopLoss, takeProfit, InpTradeComment);
    }
    
    if(result) {
        if(trade.ResultRetcode() == TRADE_RETCODE_DONE) {
            Print("Order executed successfully. Ticket: ", trade.ResultOrder());
        } else {
            Print("Order execution failed. Error: ", trade.ResultRetcode());
        }
    }
}

//+------------------------------------------------------------------+
//| Calculate position size based on risk management                   |
//+------------------------------------------------------------------+
double CalculatePositionSize(ENUM_ORDER_TYPE orderType) {
    if(InpPositionSizeType == FIXED_LOT) {
        return NormalizeVolume(InpFixedLotSize);
    }
    
    // Calculate based on risk percentage
    double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * (InpRiskPercent / 100.0);
    double stopLossPoints = 0;
    
    if(InpUseAtrSL) {
        stopLossPoints = atrBuffer[0] * InpAtrSlMultiplier / Point();
    } else if(InpUseFixedSL) {
        stopLossPoints = InpFixedSLPips;
    } else {
        return NormalizeVolume(InpFixedLotSize); // Default to fixed lot if no SL
    }
    
    if(stopLossPoints <= 0) return 0;
    
    double tickSize = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_SIZE);
    double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
    double pointCost = tickValue * (Point() / tickSize);
    
    double volume = riskAmount / (stopLossPoints * pointCost);
    return NormalizeVolume(volume);
}

//+------------------------------------------------------------------+
//| Normalize volume according to symbol settings                      |
//+------------------------------------------------------------------+
double NormalizeVolume(double volume) {
    double minVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
    double maxVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
    double stepVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);
    
    volume = MathFloor(volume / stepVolume) * stepVolume;
    volume = MathMax(minVolume, MathMin(maxVolume, volume));
    
    return NormalizeDouble(volume, 2);
}

//+------------------------------------------------------------------+
//| Calculate stop loss level                                         |
//+------------------------------------------------------------------+
double CalculateStopLoss(ENUM_ORDER_TYPE orderType, double entryPrice) {
    if(!InpUseAtrSL && !InpUseFixedSL) return 0;
    
    double stopLossPoints;
    if(InpUseAtrSL) {
        stopLossPoints = atrBuffer[0] * InpAtrSlMultiplier;
    } else {
        stopLossPoints = InpFixedSLPips * Point();
    }
    
    double stopLoss = (orderType == ORDER_TYPE_BUY) ? 
                      entryPrice - stopLossPoints : 
                      entryPrice + stopLossPoints;
                      
    return NormalizeDouble(stopLoss, Digits());
}

//+------------------------------------------------------------------+
//| Calculate take profit level                                       |
//+------------------------------------------------------------------+
double CalculateTakeProfit(ENUM_ORDER_TYPE orderType, double entryPrice, double stopLoss) {
    if(!InpUseAtrTP && !InpUseFixedTP) return 0;
    
    double takeProfitPoints;
    if(InpUseAtrTP) {
        takeProfitPoints = atrBuffer[0] * InpAtrTpMultiplier;
    } else {
        takeProfitPoints = InpFixedTPPips * Point();
    }
    
    double takeProfit = (orderType == ORDER_TYPE_BUY) ? 
                        entryPrice + takeProfitPoints : 
                        entryPrice - takeProfitPoints;
                        
    return NormalizeDouble(takeProfit, Digits());
}

//+------------------------------------------------------------------+
//| Check if candlestick pattern is valid                             |
//+------------------------------------------------------------------+
bool IsValidPattern(const MqlRates &current, const MqlRates &previous, 
                   ENUM_BREAKOUT_CANDLE_PATTERN pattern) {
    switch(pattern) {
        case ANY_BULLISH:
            return (current.close > current.open);
            
        case ANY_BEARISH:
            return (current.close < current.open);
            
        case ENGULFING_BULLISH:
            return (current.close > current.open &&
                   previous.close < previous.open &&
                   current.close > previous.open &&
                   current.open < previous.close);
                   
        case ENGULFING_BEARISH:
            return (current.close < current.open &&
                   previous.close > previous.open &&
                   current.close < previous.open &&
                   current.open > previous.close);
                   
        case MARUBOZU_BULLISH:
            return IsBullishMarubozu(current);
            
        case MARUBOZU_BEARISH:
            return IsBearishMarubozu(current);
            
        default:
            return false;
    }
}

//+------------------------------------------------------------------+
//| Check if candle is a Marubozu                                     |
//+------------------------------------------------------------------+
bool IsBullishMarubozu(const MqlRates &candle) {
    double bodySize = candle.close - candle.open;
    double upperWick = candle.high - candle.close;
    double lowerWick = candle.open - candle.low;
    
    if(bodySize <= 0) return false;
    
    double totalSize = candle.high - candle.low;
    double bodyRatio = bodySize / totalSize;
    
    return (bodyRatio >= 0.9 && upperWick/bodySize <= 0.1 && lowerWick/bodySize <= 0.1);
}

//+------------------------------------------------------------------+
//| Check if candle is a Bearish Marubozu                             |
//+------------------------------------------------------------------+
bool IsBearishMarubozu(const MqlRates &candle) {
    double bodySize = candle.open - candle.close;
    double upperWick = candle.high - candle.open;
    double lowerWick = candle.close - candle.low;
    
    if(bodySize <= 0) return false;
    
    double totalSize = candle.high - candle.low;
    double bodyRatio = bodySize / totalSize;
    
    return (bodyRatio >= 0.9 && upperWick/bodySize <= 0.1 && lowerWick/bodySize <= 0.1);
}
//+------------------------------------------------------------------+
//| Manage open positions                                             |
//+------------------------------------------------------------------+
void ManageOpenPositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(ticket <= 0) continue;
        
        if(PositionGetString(POSITION_SYMBOL) != Symbol()) continue;
        if(PositionGetInteger(POSITION_MAGIC) != InpMagicNumber) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double posOpenPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentSL = PositionGetDouble(POSITION_SL);
        
        // Check time-based exit
        if(CheckTimeBasedExit(ticket, posType)) continue;
        
        // Update trailing stop if enabled
        UpdateTrailingStop(ticket, posType, posOpenPrice, currentSL);
    }
}

//+------------------------------------------------------------------+
//| Check and handle time-based exit                                  |
//+------------------------------------------------------------------+
bool CheckTimeBasedExit(ulong ticket, ENUM_POSITION_TYPE posType) {
    if(!InpUseTimeBasedExit) return false;
    
    datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
    datetime currentTime = TimeCurrent();
    
    double hoursElapsed = (currentTime - openTime) / 3600.0;
    double exitHours = 0;
    
    switch(InpTimeBasedExitDuration) {
        case HOURS_1:  exitHours = 1; break;
        case HOURS_2:  exitHours = 2; break;
        case HOURS_4:  exitHours = 4; break;
        case HOURS_8:  exitHours = 8; break;
        case HOURS_12: exitHours = 12; break;
        case HOURS_24: exitHours = 24; break;
        case CUSTOM_HOURS: exitHours = InpCustomExitHours; break;
    }
    
    if(hoursElapsed >= exitHours) {
        ClosePosition(ticket);
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Update trailing stop for position                                 |
//+------------------------------------------------------------------+
void UpdateTrailingStop(ulong ticket, ENUM_POSITION_TYPE posType, 
                       double openPrice, double currentSL) {
    if(!InpUseTrailingStop) return;
    
    double newSL = 0;
    double atrValue = atrBuffer[0];
    double currentPrice = (posType == POSITION_TYPE_BUY) ? 
                          symbolInfo.Bid() : symbolInfo.Ask();
    
    // Calculate activation level
    double activationLevel = InpTrailingActivationPips * Point();
    double profitPoints = (posType == POSITION_TYPE_BUY) ? 
                          currentPrice - openPrice : 
                          openPrice - currentPrice;
    
    if(profitPoints < activationLevel) return;
    
    // Calculate new stop loss
    if(posType == POSITION_TYPE_BUY) {
        newSL = currentPrice - (atrValue * InpAtrTrailingMultiplier);
        if(newSL <= currentSL) return;
    } else {
        newSL = currentPrice + (atrValue * InpAtrTrailingMultiplier);
        if(newSL >= currentSL && currentSL != 0) return;
    }
    
    // Modify stop loss
    trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
}

//+------------------------------------------------------------------+
//| Close position by ticket                                          |
//+------------------------------------------------------------------+
bool ClosePosition(ulong ticket) {
    if(!PositionSelectByTicket(ticket)) return false;
    
    return trade.PositionClose(ticket);
}

//+------------------------------------------------------------------+
//| Check if volume meets filter criteria                             |
//+------------------------------------------------------------------+
bool IsVolumeValid(double currentVolume) {
    if(!InpUseVolumeFilter) return true;
    
    double volumeMA = CalculateVolumeMA(InpVolumeAvgPeriod);
    return (currentVolume > volumeMA);
}

//+------------------------------------------------------------------+
//| Calculate Volume Moving Average                                    |
//+------------------------------------------------------------------+
double CalculateVolumeMA(int period) {
    double volumeArray[];
    ArraySetAsSeries(volumeArray, true);
    
    int copied = CopyTickVolume(Symbol(), Period(), 0, period, volumeArray);
    if(copied != period) return 0;
    
    double sum = 0;
    for(int i = 0; i < period; i++) {
        sum += volumeArray[i];
    }
    
    return sum / period;
}

//+------------------------------------------------------------------+
//| Custom error handling                                             |
//+------------------------------------------------------------------+
void HandleTradingError(int errorCode) {
    switch(errorCode) {
        case TRADE_RETCODE_INVALID_STOPS:
            Print("Error: Invalid stop loss or take profit levels");
            break;
        case TRADE_RETCODE_INVALID_VOLUME:
            Print("Error: Invalid volume");
            break;
        case TRADE_RETCODE_INVALID_PRICE:
            Print("Error: Invalid price");
            break;
        case TRADE_RETCODE_TRADE_DISABLED:
            Print("Error: Trading is disabled");
            break;
        default:
            Print("Error code: ", errorCode);
            break;
    }
}

//+------------------------------------------------------------------+
//| Draw debug information on chart                                   |
//+------------------------------------------------------------------+
void ShowDebugInfo() {
    string info = "GeminiBreakout EA Status\n";
    info += "-------------------\n";
    info += "Balance: " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2) + "\n";
    info += "Equity: " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + "\n";
    info += "Spread: " + IntegerToString(SymbolInfoInteger(Symbol(), SYMBOL_SPREAD)) + "\n";
    info += "ATR: " + DoubleToString(atrBuffer[0], 5) + "\n";
    info += "Donchian Upper: " + DoubleToString(donchianUpperBuffer[0], 5) + "\n";
    info += "Donchian Lower: " + DoubleToString(donchianLowerBuffer[0], 5) + "\n";
    
    Comment(info);
}

//+------------------------------------------------------------------+
//| Timer event handler                                               |
//+------------------------------------------------------------------+
void OnTimer() {
    ShowDebugInfo();
}
