//+------------------------------------------------------------------+
//|                                         MultiStrategy_Pro_EA.mql5 |
//|                                Copyright 2025, margincall2        |
//|                              Updated: 2025-02-21 10:15:30 UTC     |
//+------------------------------------------------------------------+
#property copyright   "Copyright 2025, margincall2"
#property version    "1.0"
#property strict

// Enums
enum ENUM_SIGNAL_TYPE {
    SIGNAL_BUY,    // Buy Signal
    SIGNAL_SELL,   // Sell Signal
    SIGNAL_NONE    // No Signal
};

// Input Parameters
input int    DonchianPeriod     = 20;      // Donchian Channel Period
input int    FiboPeriod         = 20;      // Fibonacci Period
input double RiskPercent        = 1.0;     // Risk Percent per Trade
input bool   UseVolatilitySize  = true;    // Use Volatility-Based Position Size
input bool   MultiTimeframe     = true;    // Use Multi-Timeframe Analysis
input bool   EnableDebugInfo    = true;    // Enable Debug Information
input double StopLossPoints     = 30;      // Fixed Stop Loss (points)
input double TrailingStopPoints = 20;      // Trailing Stop (points)
input double BreakEvenPoints    = 10;      // Break Even (points)
input double MaxSpreadPoints    = 5;       // Maximum Spread (points)

// Global Variables for Debug Info
string   g_DebugInfo = "";
datetime g_LastDebugUpdate = 0;

//+------------------------------------------------------------------+
//| Donchian Channel Functions                                       |
//+------------------------------------------------------------------+
double DonchianUpper(int period, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT) {
    double highest = 0;
    for(int i = 0; i < period; i++) {
        highest = MathMax(highest, iHigh(NULL, timeframe, i));
    }
    return highest;
}

double DonchianLower(int period, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT) {
    double lowest = DBL_MAX;
    for(int i = 0; i < period; i++) {
        lowest = MathMin(lowest, iLow(NULL, timeframe, i));
    }
    return lowest;
}

double DonchianMiddle(int period, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT) {
    return (DonchianUpper(period, timeframe) + DonchianLower(period, timeframe)) / 2;
}

//+------------------------------------------------------------------+
//| Candlestick Pattern Functions                                    |
//+------------------------------------------------------------------+
bool IsBullishEngulfing(int shift) {
    if(Close[shift] > Open[shift] &&           // Current candle is bullish
       Open[shift+1] > Close[shift+1] &&       // Previous candle is bearish
       Open[shift] < Close[shift+1] &&         // Current open below prev close
       Close[shift] > Open[shift+1])           // Current close above prev open
        return true;
    return false;
}

bool IsBearishEngulfing(int shift) {
    if(Close[shift] < Open[shift] &&           // Current candle is bearish
       Open[shift+1] < Close[shift+1] &&       // Previous candle is bullish
       Open[shift] > Close[shift+1] &&         // Current open above prev close
       Close[shift] < Open[shift+1])           // Current close below prev open
        return true;
    return false;
}

//+------------------------------------------------------------------+
//| Fibonacci Functions                                              |
//+------------------------------------------------------------------+
double[] CalculateFiboLevels(double high, double low) {
    double fiboLevels[];
    ArrayResize(fiboLevels, 6);
    
    fiboLevels[0] = low + (high - low) * 0.236;
    fiboLevels[1] = low + (high - low) * 0.382;
    fiboLevels[2] = low + (high - low) * 0.5;
    fiboLevels[3] = low + (high - low) * 0.618;
    fiboLevels[4] = low + (high - low) * 0.786;
    fiboLevels[5] = high;
    
    return fiboLevels;
}

//+------------------------------------------------------------------+
//| Calculate Total Volume and Lots                                  |
//+------------------------------------------------------------------+
void CalculateTotalVolumeAndLots(double &totalVolume, double &totalLots) {
    totalVolume = 0.0;
    totalLots = 0.0;
    
    for(int i = 0; i < OrdersTotal(); i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            if(OrderSymbol() == Symbol()) {
                totalLots += OrderLots();
                totalVolume += OrderLots() * OrderOpenPrice();
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Update Debug Information                                         |
//+------------------------------------------------------------------+
void UpdateDebugInfo(ENUM_SIGNAL_TYPE signal, double currentLot = 0.0) {
    if(!EnableDebugInfo) return;
    
    // Only update debug info every second to reduce CPU load
    if(TimeCurrent() - g_LastDebugUpdate < 1) return;
    g_LastDebugUpdate = TimeCurrent();
    
    // Get account information
    string accountName = AccountInfoString(ACCOUNT_NAME);
    long accountNumber = AccountInfoInteger(ACCOUNT_LOGIN);
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    
    // Calculate total volume and lots
    double totalVolume = 0.0;
    double totalLots = 0.0;
    CalculateTotalVolumeAndLots(totalVolume, totalLots);
    
    // Get current spread
    double currentSpread = SymbolInfoInteger(Symbol(), SYMBOL_SPREAD) * Point();
    
    // Format the debug info
    g_DebugInfo = "=== MultiStrategy Pro EA Debug Info ===\n";
    g_DebugInfo += StringFormat("Account: %s (#%d)\n", accountName, accountNumber);
    g_DebugInfo += StringFormat("Balance: %.2f | Equity: %.2f\n", accountBalance, accountEquity);
    g_DebugInfo += StringFormat("Risk: %.2f%% (%.2f currency units)\n", 
                               RiskPercent, accountBalance * RiskPercent / 100);
    g_DebugInfo += StringFormat("Total Lots: %.2f | Total Volume: %.2f\n", totalLots, totalVolume);
    g_DebugInfo += StringFormat("Current Lot: %.2f | Current Spread: %d points\n", 
                               currentLot, (int)(currentSpread/Point()));
    
    // Signal information
    string signalInfo = "No Signal";
    if(signal == SIGNAL_BUY) signalInfo = "BUY Signal Active";
    if(signal == SIGNAL_SELL) signalInfo = "SELL Signal Active";
    g_DebugInfo += StringFormat("Signal: %s\n", signalInfo);
    
    // Strategy parameters
    g_DebugInfo += "--- Strategy Parameters ---\n";
    g_DebugInfo += StringFormat("Donchian Period: %d | Fibo Period: %d\n", DonchianPeriod, FiboPeriod);
    g_DebugInfo += StringFormat("Volatility Sizing: %s | Multi-Timeframe: %s\n", 
                               UseVolatilitySize ? "Enabled" : "Disabled",
                               MultiTimeframe ? "Enabled" : "Disabled");
    
    // Market levels
    double upperDonchian = DonchianUpper(DonchianPeriod);
    double lowerDonchian = DonchianLower(DonchianPeriod);
    g_DebugInfo += "--- Market Levels ---\n";
    g_DebugInfo += StringFormat("Donchian Upper: %.5f\n", upperDonchian);
    g_DebugInfo += StringFormat("Donchian Lower: %.5f\n", lowerDonchian);
    g_DebugInfo += StringFormat("ATR(14): %.5f\n", iATR(NULL, PERIOD_CURRENT, 14, 0));
    
    // Display comment
    Comment(g_DebugInfo);
}

//+------------------------------------------------------------------+
//| Check for Trading Signals                                        |
//+------------------------------------------------------------------+
ENUM_SIGNAL_TYPE CheckSignals() {
    // Donchian Breakout Check
    double upperDonchian = DonchianUpper(DonchianPeriod);
    double lowerDonchian = DonchianLower(DonchianPeriod);
    
    // Multi-Timeframe Confirmation
    bool mtfConfirm = true;
    if(MultiTimeframe) {
        double upperH1 = DonchianUpper(DonchianPeriod, PERIOD_H1);
        double lowerH1 = DonchianLower(DonchianPeriod, PERIOD_H1);
        mtfConfirm = (Close[1] > upperH1 || Close[1] < lowerH1);
    }
    
    // Bullish Signal
    if(Close[1] > upperDonchian && IsBullishEngulfing(1) && mtfConfirm) {
        return SIGNAL_BUY;
    }
    
    // Bearish Signal
    if(Close[1] < lowerDonchian && IsBearishEngulfing(1) && mtfConfirm) {
        return SIGNAL_SELL;
    }
    
    return SIGNAL_NONE;
}

//+------------------------------------------------------------------+
//| Calculate Position Size                                          |
//+------------------------------------------------------------------+
double CalculatePositionSize(double stopLoss) {
    double riskAmount = AccountBalance() * RiskPercent / 100;
    double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
    
    double atrMultiplier = 1.0;
    if(UseVolatilitySize) {
        double atr = iATR(NULL, PERIOD_CURRENT, 14, 0);
        double avgAtr = iATR(NULL, PERIOD_CURRENT, 14, 10); // Average ATR
        atrMultiplier = atr / avgAtr;
    }
    
    double lotSize = NormalizeDouble((riskAmount * atrMultiplier) / (stopLoss * tickValue), 2);
    lotSize = MathMin(lotSize, SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX));
    lotSize = MathMax(lotSize, SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN));
    
    return lotSize;
}

//+------------------------------------------------------------------+
//| Place Pending Orders                                             |
//+------------------------------------------------------------------+
void PlacePendingOrders(ENUM_SIGNAL_TYPE signal) {
    double upperDonchian = DonchianUpper(DonchianPeriod);
    double lowerDonchian = DonchianLower(DonchianPeriod);
    double middleDonchian = DonchianMiddle(DonchianPeriod);
    
    // Calculate Fibonacci levels
    double[] fiboLevels = CalculateFiboLevels(upperDonchian, lowerDonchian);
    
    if(signal == SIGNAL_BUY) {
        double buyStop = upperDonchian + 10 * Point;
        double sellStop = middleDonchian - 10 * Point;
        double stopLoss = buyStop - StopLossPoints * Point;
        double takeProfit = upperDonchian + (upperDonchian - middleDonchian);
        
        double lotSize = CalculatePositionSize(MathAbs(buyStop - stopLoss));
        
        // Update debug info with calculated lot size
        UpdateDebugInfo(signal, lotSize);
        
        // Place Buy Stop
        OrderSend(Symbol(), OP_BUYSTOP, lotSize, buyStop, 3, stopLoss, takeProfit, 
                 "Buy Stop", 0, 0, clrBlue);
                 
        // Place Sell Stop for reversal
        OrderSend(Symbol(), OP_SELLSTOP, lotSize, sellStop, 3, upperDonchian, lowerDonchian, 
                 "Sell Stop", 0, 0, clrRed);
    }
    
    if(signal == SIGNAL_SELL) {
        double sellStop = lowerDonchian - 10 * Point;
        double buyStop = middleDonchian + 10 * Point;
        double stopLoss = sellStop + StopLossPoints * Point;
        double takeProfit = lowerDonchian - (middleDonchian - lowerDonchian);
        
        double lotSize = CalculatePositionSize(MathAbs(sellStop - stopLoss));
        
        // Update debug info with calculated lot size
        UpdateDebugInfo(signal, lotSize);
        
        // Place Sell Stop
        OrderSend(Symbol(), OP_SELLSTOP, lotSize, sellStop, 3, stopLoss, takeProfit, 
                 "Sell Stop", 0, 0, clrRed);
                 
        // Place Buy Stop for reversal
        OrderSend(Symbol(), OP_BUYSTOP, lotSize, buyStop, 3, lowerDonchian, upperDonchian, 
                 "Buy Stop", 0, 0, clrBlue);
    }
}

//+------------------------------------------------------------------+
//| Manage Pending Orders                                            |
//+------------------------------------------------------------------+
void ManagePendingOrders() {
    double currentSpread = SymbolInfoInteger(Symbol(), SYMBOL_SPREAD) * Point();
    
    // If spread is too high, cancel pending orders
    if(currentSpread > MaxSpreadPoints * Point) {
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            if(OrderSelect(i, SELECT_BY_POS)) {
                if(OrderType() == OP_BUYSTOP || OrderType() == OP_SELLSTOP) {
                    OrderDelete(OrderTicket());
                }
            }
        }
    } else {
        // If spread is normal, place orders based on current signal
        ENUM_SIGNAL_TYPE currentSignal = CheckSignals();
        if(currentSignal != SIGNAL_NONE) {
            PlacePendingOrders(currentSignal);
        }
    }
}

//+------------------------------------------------------------------+
//| Manage Open Orders                                               |
//+------------------------------------------------------------------+
void ManageOpenOrders() {
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            double openPrice = OrderOpenPrice();
            double currentPrice = OrderType() == OP_BUY ? Bid : Ask;
            double stopLoss = OrderStopLoss();
            double takeProfit = OrderTakeProfit();
            
            // Break Even
            if(OrderType() == OP_BUY && currentPrice >= openPrice + BreakEvenPoints * Point) {
                OrderModify(OrderTicket(), openPrice, openPrice + 1 * Point, takeProfit, 0, clrGreen);
            }
            if(OrderType() == OP_SELL && currentPrice <= openPrice - BreakEvenPoints * Point) {
                OrderModify(OrderTicket(), openPrice, openPrice - 1 * Point, takeProfit, 0, clrGreen);
            }
            
            // Trailing Stop
            if(OrderType() == OP_BUY && currentPrice - openPrice >= TrailingStopPoints * Point) {
                double newStopLoss = currentPrice - TrailingStopPoints * Point;
                if(newStopLoss > stopLoss) {
                    OrderModify(OrderTicket(), openPrice, newStopLoss, takeProfit, 0, clrGreen);
                }
            }
            if(OrderType() == OP_SELL && openPrice - currentPrice >= TrailingStopPoints * Point) {
                double newStopLoss = currentPrice + TrailingStopPoints * Point;
                if(newStopLoss < stopLoss) {
                    OrderModify(OrderTicket(), openPrice, newStopLoss, takeProfit, 0, clrGreen);
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    // Initial debug info update
    UpdateDebugInfo(SIGNAL_NONE);
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // Clear any comments on exit
    Comment("");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
    // Manage pending orders based on spread and signal
    ManagePendingOrders();
    
    // Manage open orders
    ManageOpenOrders();
}
