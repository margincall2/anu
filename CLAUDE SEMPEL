//+------------------------------------------------------------------+
//| Expert advisor program code                                      |
//| Name: GeminiKuBreak.mq5                                         |
//| Author: Gemini AI                                                 |
//| Description: Breakout Expert Advisor based on High/Low levels,   |
//|              Candlestick Patterns, and ATR/Donchian SL/TP        |
//+------------------------------------------------------------------+
#property copyright   "Gemini AI"
#property link        ""
#property version     "1.0"
#property description "Breakout Expert Advisor based on High/Low levels and Candlestick Patterns"

#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh> // Menambahkan include untuk CSymbolInfo
#include <stdlib.mqh>           // Untuk ErrorDescription()

//--- Deklarasi Enum dan Parameter Input ---
enum ENUM_SLTP_METHOD {
    MANUAL,              // Manual Fixed SL/TP
    DONCHIAN_SLTP,       // Donchian Channel Based SL/TP
    ATR_SLTP             // ATR Based SL/TP
};

enum ENUM_CANDLE_PATTERNS {
    ENGULFING_BULLISH,    // Bullish Engulfing Pattern
    ENGULFING_BEARISH,    // Bearish Engulfing Pattern
    NONE                 // No Candlestick Pattern Confirmation
};

//--- Parameter Input ---
input group "General Settings";
input int      InpMagicNumber = 123456;      // Magic Number
input string   InpTradeComment = "GeminiKuBreak"; // Trade Comment
input ENUM_TIMEFRAMES InpLowTimeframe = PERIOD_M15; // Trading Timeframe
input ENUM_TIMEFRAMES Inp_HighLowTimeframe = PERIOD_H1; // Timeframe for High/Low Levels
input double   InpLots = 0.01;               // Base Lot Size
input double   InpMaxRiskPercent = 2.0;      // Maximum Risk per Trade (%)

input group "Breakout Signal Settings";
input bool     InpUseCandlePatternConfirmation = true; // Use Candlestick Pattern Confirmation (true)
input ENUM_CANDLE_PATTERNS InpBuyPattern = ENGULFING_BULLISH; // Buy Candlestick Pattern
input ENUM_CANDLE_PATTERNS InpSellPattern = ENGULFING_BEARISH; // Sell Candlestick Pattern
input bool     InpUseVolumeFilter = false;     // Use Volume Filter (false)
input double   InpVolumeThresholdMultiplier = 1.5; // Volume Threshold Multiplier

input group "Donchian Channel Settings";
input int      InpDonchianPeriod = 20;         // Donchian Channel Period (20)
input bool     InpUseDonchianAtrLikeSlTp = true;      // Use ATR-like SL/TP for Donchian (true)

input group "ATR Settings";
input int      InpAtrPeriod = 14;              // ATR Period (14)
input double   InpAtrSlMultiplier = 2.0;       // ATR SL Multiplier (2.0)
input double   InpAtrTpMultiplier = 3.0;       // ATR TP Multiplier (3.0)

input group "Stop Loss Settings";
input ENUM_SLTP_METHOD InpSLTPMethod = ATR_SLTP;         // SL/TP Method (ATR, DONCHIAN_SLTP, MANUAL)
input bool     InpUseFixedSL = false;          // Use Fixed Stop Loss (false)
input int      InpFixedSLPips = 50;            // Fixed Stop Loss Pips (50)
input bool     InpUseAtrSL = true;           // Use ATR for Stop Loss (true)

input group "Take Profit Settings";
input bool     InpUseFixedTP = false;          // Use Fixed Take Profit (false)
input int      InpFixedTPPips = 100;           // Fixed Take Profit Pips (100)
input bool     InpUseAtrTP = true;           // Use ATR for Take Profit (true)

input group "Trailing Stop Settings";
input bool     InpUseTrailingStop = false;     // Use Trailing Stop (false)
input int      InpTrailingStopPips = 30;       // Trailing Stop Pips (30)
input int      InpTrailingStepPips = 5;        // Trailing Step Pips (5)

input group "Break Even Settings";
input bool     InpUseBreakEven = false;        // Use Break Even (false)
input int      InpBreakEvenPips = 20;         // Break Even Trigger Pips (20)
input int      InpBreakEvenPipsToLock = 5;    // Pips to Lock in Profit at Break Even (5)

input group "Spread Settings";
input int      InpMaxSpread = 30;            // Maximum Spread in Points (30)


//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
CTrade         trade;
CSymbolInfo    symbolInfo; // Deklarasi yang benar setelah include
ENUM_TIMEFRAMES lowTimeframe;
ENUM_TIMEFRAMES highLowTimeframe;
ENUM_TIMEFRAMES period_current;   // Current chart timeframe


//+------------------------------------------------------------------+
//| Indicator Handles and Buffers                                     |
//+------------------------------------------------------------------+
int    donchianHandle = INVALID_HANDLE;
double donchianUpperBuffer[];
double donchianLowerBuffer[];
int    atrHandle = INVALID_HANDLE;
double atrBuffer[];
double highBuffer[];                   // Buffer to store high prices for HighLow timeframe
double lowBuffer[];                    // Buffer to store low prices for HighLow timeframe
double openHighLowBuffer[];            // Buffer to store open prices for HighLow timeframe


//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
    //--- Initialize trading object
    symbolInfo.Name(Symbol());
    symbolInfo.RefreshRates();

    lowTimeframe = InpLowTimeframe;
    highLowTimeframe = Inp_HighLowTimeframe;
    period_current   = Period();

    Print("OnInit: Expert initialized for symbol ", Symbol(), " timeframe ", EnumToString(period_current));
    Print("OnInit: Trading Timeframe set to ", EnumToString(lowTimeframe));
    Print("OnInit: HighLow Timeframe set to ", EnumToString(highLowTimeframe));

    //--- Allocate arrays for indicator buffers (set as timeseries for easy access to previous values)
    ArraySetAsSeries(donchianUpperBuffer,true);
    ArraySetAsSeries(donchianLowerBuffer,true);
    ArraySetAsSeries(atrBuffer,true);
    ArraySetAsSeries(highBuffer, true);
    ArraySetAsSeries(lowBuffer, true);
    ArraySetAsSeries(openHighLowBuffer, true);

    //--- Create handles for custom indicators
    if(!CreateIndicatorHandles())
    {
        Print("OnInit: Failed to create indicator handles. Error code: ",GetLastError());
        return(INIT_FAILED);
    }
    Print("OnInit: Indicator handles created successfully");

    //--- Check for valid input parameters
    if(!CheckInputParameters())
    {
        Print("OnInit: Invalid input parameters. Please check the expert properties.");
        return(INIT_FAILED);
    }
    Print("OnInit: Input parameters are valid");

    Print("OnInit: Initialization completed successfully");
    return(INIT_SUCCEEDED);
}


//+------------------------------------------------------------------+
//| Expert deinitialization function                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    Print("OnDeinit: Expert deinitialized, reason: ", GetDeinitReasonString(reason));
    //--- Release indicator handles if they are valid
    ReleaseIndicatorHandles();
    Print("OnDeinit: Indicator handles released");
}


//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
{
    //--- Check for new bar on trading timeframe
    if(IsNewBar(lowTimeframe))
    {
        Print("OnTick: New bar detected on Trading Timeframe ", EnumToString(lowTimeframe));
        //--- Update indicator values
        if(!UpdateIndicators())
        {
            Print("OnTick: UpdateIndicators() failed, exiting OnTick");
            return;
        }
        //--- Check trading signals and execute orders
        CheckForTradingSignals();
    }

    //--- Trailing stop and Break Even functionality (if enabled)
    HandleTrailingStop();
}


//+------------------------------------------------------------------+
//| Update indicator values                                           |
//+------------------------------------------------------------------+
bool UpdateIndicators()
{
    Print("UpdateIndicators: Updating indicators...");

    //--- Clear previous indicator values before updating with new data
    ArrayInitialize(donchianUpperBuffer,0);
    ArrayInitialize(donchianLowerBuffer,0);
    ArrayInitialize(atrBuffer,0);
    ArrayInitialize(highBuffer, 0);
    ArrayInitialize(lowBuffer, 0);
    ArrayInitialize(openHighLowBuffer, 0);

    //--- Copy indicator buffers from indicators to EA buffers
    int copiedDonchianUpper = CopyBuffer(donchianHandle,0,0,2,donchianUpperBuffer); // Copy Donchian Upper Band for 2 bars
    if(copiedDonchianUpper < 2)
    {
        Print("UpdateIndicators: Failed to copy Donchian Upper buffer. Error code: ",GetLastError(), " Copied: ", copiedDonchianUpper);
        return(false);
    }
    int copiedDonchianLower = CopyBuffer(donchianHandle,1,0,2,donchianLowerBuffer); // Copy Donchian Lower Band for 2 bars
    if(copiedDonchianLower < 2)
    {
        Print("UpdateIndicators: Failed to copy Donchian Lower buffer. Error code: ",GetLastError(), " Copied: ", copiedDonchianLower);
        return(false);
    }
    int copiedAtr = CopyBuffer(atrHandle,0,0,2,atrBuffer); // Copy ATR values for 2 bars
    if(copiedAtr < 2)
    {
        Print("UpdateIndicators: Failed to copy ATR buffer. Error code: ",GetLastError(), " Copied: ", copiedAtr);
        return(false);
    }

    //--- Copy High, Low, and Open Prices for the selected HighLow Timeframe for the last 2 bars
    int copiedHighs = CopyHigh(Symbol(), highLowTimeframe, 0, 2, highBuffer);
    if(copiedHighs < 2)
    {
        Print("UpdateIndicators: Failed to copy High prices for HighLow Timeframe. Error code: ", GetLastError(), " Copied: ", copiedHighs);
        return false;
    }
    int copiedLows = CopyLow(Symbol(), highLowTimeframe, 0, 2, lowBuffer);
    if(copiedLows < 2)
    {
        Print("UpdateIndicators: Failed to copy Low prices for HighLow Timeframe. Error code: ", GetLastError(), " Copied: ", copiedLows);
        return false;
    }
    int copiedOpens = CopyOpen(Symbol(), highLowTimeframe, 0, 2, openHighLowBuffer);
    if(copiedOpens < 2)
    {
        Print("UpdateIndicators: Failed to copy Open prices for HighLow Timeframe. Error code: ", GetLastError(), " Copied: ", copiedOpens);
        return false;
    }


    Print("UpdateIndicators: Indicators updated successfully");
    Print("UpdateIndicators: Donchian Upper[0]: ", donchianUpperBuffer[0]);
    Print("UpdateIndicators: Donchian Lower[0]: ", donchianLowerBuffer[0]);
    Print("UpdateIndicators: ATR[0]: ", atrBuffer[0]);
    Print("UpdateIndicators: High[0] (HighLow TF): ", highBuffer[0]);
    Print("UpdateIndicators: Low[0] (HighLow TF): ", lowBuffer[0]);
    Print("UpdateIndicators: Open[0] (HighLow TF): ", openHighLowBuffer[0]);

    return(true);
}


//+------------------------------------------------------------------+
//| Check input parameters for validity                               |
//+------------------------------------------------------------------+
bool CheckInputParameters()
{
    if(InpLots<=0 || InpMaxRiskPercent<=0 || InpDonchianPeriod<=0 || InpAtrPeriod<=0 || InpAtrSlMultiplier<=0 || InpAtrTpMultiplier<=0)
    {
        Print("CheckInputParameters: Invalid input parameters detected.");
        return(false);
    }
    if((InpUseFixedSL && InpFixedSLPips<=0) || (InpUseFixedTP && InpFixedTPPips<=0))
    {
        Print("CheckInputParameters: Fixed SL/TP Pips must be greater than zero if used.");
        return(false);
    }
    if(InpUseTrailingStop && (InpTrailingStopPips<=0 || InpTrailingStepPips<=0))
    {
        Print("CheckInputParameters: Trailing Stop/Step Pips must be greater than zero if Trailing Stop is used.");
        return(false);
    }
    if(InpBreakEvenPips < 0 || InpBreakEvenPipsToLock < 0)
    {
        Print("CheckInputParameters: Break Even Pips and Break Even Pips To Lock must be non-negative.");
        return(false);
    }
    if(InpMaxSpread < 0)
    {
        Print("CheckInputParameters: Max Spread must be non-negative.");
        return(false);
    }
    return(true);
}


//+------------------------------------------------------------------+
//| Create indicator handles                                        |
//+------------------------------------------------------------------+
bool CreateIndicatorHandles()
{
    int error = 0;
    //--- Donchian Channel handle
    donchianHandle = iDonchian(Symbol(), Inp_HighLowTimeframe, InpDonchianPeriod); // Corrected iDonchian function call, using HighLow timeframe
    if(donchianHandle==INVALID_HANDLE)
    {
        error = GetLastError();
        Print("CreateIndicatorHandles: Error creating Donchian Channel indicator handle: ",ErrorDescription(error)," error=",error);
        return(false);
    }
    //--- ATR handle
    atrHandle = iATR(Symbol(), period_current, InpAtrPeriod); // Corrected iATR function call, using current chart timeframe
    if(atrHandle==INVALID_HANDLE)
    {
        error = GetLastError();
        Print("CreateIndicatorHandles: Error creating ATR indicator handle: ",ErrorDescription(error)," error=",error);
        return(false);
    }
    return(true);
}


//+------------------------------------------------------------------+
//| Release indicator handles                                         |
//+------------------------------------------------------------------+
void ReleaseIndicatorHandles()
{
    if(donchianHandle!=INVALID_HANDLE) IndicatorRelease(donchianHandle);
    if(atrHandle!=INVALID_HANDLE)      IndicatorRelease(atrHandle);
}


//+------------------------------------------------------------------+
//| Check for trading signals                                         |
//+------------------------------------------------------------------+
void CheckForTradingSignals()
{
    Print("CheckForTradingSignals: Checking for trading signals...");

    bool buySignal = false;
    bool sellSignal = false;

    //--- Check for Buy Signal: Current Ask price breaks above previous High of HighLow timeframe
    if(symbolInfo.Ask() > highBuffer[1])
    {
        Print("CheckForTradingSignals: Potential Buy Breakout detected");
        if(IsBuyCandlePatternValid()) // Check for Candlestick Pattern Confirmation if enabled
        {
            Print("CheckForTradingSignals: Buy Candlestick Pattern Confirmation is valid");
            if(IsVolumeConfirmationValid(ORDER_TYPE_BUY)) // Check for Volume Confirmation if enabled
            {
                Print("CheckForTradingSignals: Buy Volume Confirmation is valid");
                buySignal = true; // Buy signal confirmed after all confirmations
            }
            else
            {
                Print("CheckForTradingSignals: Buy Volume Confirmation is NOT valid");
            }
        }
        else
        {
            Print("CheckForTradingSignals: Buy Candlestick Pattern Confirmation is NOT valid");
        }
    }


    //--- Check for Sell Signal: Current Bid price breaks below previous Low of HighLow timeframe
    if(symbolInfo.Bid() < lowBuffer[1])
    {
        Print("CheckForTradingSignals: Potential Sell Breakout detected");
        if(IsSellCandlePatternValid()) // Check for Candlestick Pattern Confirmation if enabled
        {
            Print("CheckForTradingSignals: Sell Candlestick Pattern Confirmation is valid");
            if(IsVolumeConfirmationValid(ORDER_TYPE_SELL)) // Check for Volume Confirmation if enabled
            {
                Print("CheckForTradingSignals: Sell Volume Confirmation is valid");
                sellSignal = true; // Sell signal confirmed after all confirmations
            }
            else
            {
                Print("CheckForTradingSignals: Sell Volume Confirmation is NOT valid");
            }
        }
        else
        {
            Print("CheckForTradingSignals: Sell Candlestick Pattern Confirmation is NOT valid");
        }
    }


    //--- Place pending orders if signals are valid
    if(buySignal) PlacePendingOrder(ORDER_TYPE_BUY, highBuffer[1], lowBuffer[1]);
    if(sellSignal) PlacePendingOrder(ORDER_TYPE_SELL, highBuffer[1], lowBuffer[1]);
    Print("CheckForTradingSignals: End of CheckForTradingSignals function");
}


//+------------------------------------------------------------------+
//| Check if Buy Candlestick Pattern is Valid                       |
//+------------------------------------------------------------------+
bool IsBuyCandlePatternValid()
{
    if(!InpUseCandlePatternConfirmation) return(true); // If pattern confirmation is disabled, consider valid

    ENUM_CANDLE_PATTERNS pattern = InpBuyPattern;

    switch(pattern)
    {
        case ENGULFING_BULLISH:
            //--- Placeholder: Add logic to detect Bullish Engulfing pattern if needed ---
            Print("IsBuyCandlePatternValid: Bullish Engulfing pattern check - NOT IMPLEMENTED YET, returning TRUE"); // Placeholder
            return(true); // <<< Placeholder - Implement Bullish Engulfing detection logic here >>>
            break;
        //--- Add cases for other Buy patterns if needed ---
        case NONE:
        default:
            return(true); // No pattern selected or NONE, considered valid
            break;
    }
    return(false); // Default return false if no pattern matched and confirmation is enabled
}


//+------------------------------------------------------------------+
//| Check if Sell Candlestick Pattern is Valid                      |
//+------------------------------------------------------------------+
bool IsSellCandlePatternValid()
{
    if(!InpUseCandlePatternConfirmation) return(true); // If pattern confirmation is disabled, consider valid

    ENUM_CANDLE_PATTERNS pattern = InpSellPattern;

    switch(pattern)
    {
        case ENGULFING_BEARISH:
            //--- Placeholder: Add logic to detect Bearish Engulfing pattern if needed ---
            Print("IsSellCandlePatternValid: Bearish Engulfing pattern check - NOT IMPLEMENTED YET, returning TRUE"); // Placeholder
            return(true); // <<< Placeholder - Implement Bearish Engulfing detection logic here >>>
            break;
        //--- Add cases for other Sell patterns if needed ---
        case NONE:
        default:
            return(true); // No pattern selected or NONE, considered valid
            break;
    }
    return(false); // Default return false if no pattern matched and confirmation is enabled
}


//+------------------------------------------------------------------+
//| Is Volume Confirmation Valid                                      |
//+------------------------------------------------------------------+
bool IsVolumeConfirmationValid(ENUM_ORDER_TYPE orderType)
{
    if(!InpUseVolumeFilter) return(true); // If volume filter is disabled, consider valid

    MqlRates rates[];
    if(CopyRates(Symbol(), lowTimeframe, 0, 21, rates) < 21) return false; // Copy rates for volumePeriod + 1 bars

    long currentVolume = rates[0].tick_volume; // Volume of the current bar
    long averageVolume = 0;
    int  volumePeriod = 20; // Period for average volume calculation

    //--- Calculate average volume over the past 'volumePeriod' bars
    for(int i=1; i<=volumePeriod; i++) // Start from index 1 to exclude current bar
    {
        averageVolume += rates[i].tick_volume;
    }
    averageVolume = averageVolume / volumePeriod;

    double volumeThreshold = averageVolume * InpVolumeThresholdMultiplier; // Threshold for volume confirmation

    if(orderType == ORDER_TYPE_BUY)
    {
        if(currentVolume > volumeThreshold)
        {
            Print("IsVolumeConfirmationValid: Buy Volume Confirmation - Current Volume: ", currentVolume, ", Threshold: ", volumeThreshold, " - VALID");
            return(true);
        }
        else
        {
            Print("IsVolumeConfirmationValid: Buy Volume Confirmation - Current Volume: ", currentVolume, ", Threshold: ", volumeThreshold, " - NOT VALID");
            return(false);
        }
    }
    else if(orderType == ORDER_TYPE_SELL)
    {
        if(currentVolume > volumeThreshold)
        {
            Print("IsVolumeConfirmationValid: Sell Volume Confirmation - Current Volume: ", currentVolume, ", Threshold: ", volumeThreshold, " - VALID");
            return(true);
        }
        else
        {
            Print("IsVolumeConfirmationValid: Sell Volume Confirmation - Current Volume: ", currentVolume, ", Threshold: ", volumeThreshold, " - NOT VALID");
            return(false);
        }
    }

    return(false); // Default return false if order type is not BUY or SELL
}


//+------------------------------------------------------------------+
//| Calculate position size based on risk percentage                 |
//+------------------------------------------------------------------+
double CalculatePositionSize(ENUM_ORDER_TYPE orderType)
{
    double balance = AccountInfoDouble(ACCOUNT_BALANCE); // Account balance
    double riskPerTrade = balance * (InpMaxRiskPercent / 100.0); // Risk amount in account currency

    double stopLossPips;
    if(InpSLTPMethod == ATR_SLTP)
    {
        stopLossPips = atrBuffer[0] * InpAtrSlMultiplier / Point(); // Stop Loss in pips based on ATR
    }
    else if(InpSLTPMethod == MANUAL)
    {
        stopLossPips = InpFixedSLPips; // Fixed Stop Loss in pips
    }
    else if (InpSLTPMethod == DONCHIAN_SLTP)
    {
        //--- For Donchian, estimate SL in pips based on ATR (approximation - adjust as needed) ---
        stopLossPips = atrBuffer[0] * InpAtrSlMultiplier / Point(); // Approximation using ATR for Donchian SL
    }
    else
    {
        stopLossPips = InpFixedSLPips; // Default to Fixed SL pips if method is not recognized
    }

    if(stopLossPips <= 0)
    {
        Print("CalculatePositionSize: Stop Loss Pips is zero or negative, cannot calculate volume.");
        return(0);
    }

    double pipsValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE) * Point(); // Value of 1 pip in account currency // Corrected Point() multiplication
    double positionVolume = NormalizeDouble(riskPerTrade / (stopLossPips * pipsValue), 2); // Position volume in lots, normalized to 2 decimal places

    Print("CalculatePositionSize: Balance = ", balance, ", Risk per trade = ", riskPerTrade, ", StopLoss Pips = ", stopLossPips, ", Pip Value = ", pipsValue, ", Calculated Volume = ", positionVolume);

    //--- Ensure calculated volume is within allowed limits (minimum and maximum volume)
    if(positionVolume < SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN))
    {
        positionVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN); // Set to minimum volume if calculated volume is too low
        Print("CalculatePositionSize: Calculated volume is less than minimum volume, setting to minimum volume: ", positionVolume);
    }
    if(positionVolume > SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX))
    {
        positionVolume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX); // Set to maximum volume if calculated volume is too high
        Print("CalculatePositionSize: Calculated volume exceeds maximum volume, setting to maximum volume: ", positionVolume);
    }

    return(positionVolume);
}


//+------------------------------------------------------------------+
//| Calculate stop loss level                                         |
//+------------------------------------------------------------------+
double CalculateStopLoss(ENUM_ORDER_TYPE orderType, double entryPrice, double highLevel, double lowLevel)
{
    double stopLoss = 0;

    if(InpSLTPMethod == ATR_SLTP)
    { // ATR Stop Loss
        if(!InpUseAtrSL && !InpUseFixedSL) return(0); // If neither ATR SL nor Fixed SL is enabled, return 0 SL

        double stopLossPoints;
        if(InpUseAtrSL)
        {
            stopLossPoints = atrBuffer[0] * InpAtrSlMultiplier; // SL based on ATR multiplier
        }
        else
        {
            stopLossPoints = InpFixedSLPips * Point(); // SL based on fixed pips
        }

        stopLoss = (orderType==ORDER_TYPE_BUY) ?
                       entryPrice-stopLossPoints :
                       entryPrice+stopLossPoints;
    }
    else if(InpSLTPMethod == MANUAL)
    { // Manual Fixed Stop Loss
        if(!InpUseFixedSL && !InpUseAtrSL) return(0); // Prioritize Fixed SL if MANUAL method is selected, fallback to ATR if Fixed SL is disabled

        double stopLossPoints;
        if(InpUseFixedSL)
        {
            stopLossPoints = InpFixedSLPips * Point(); // SL based on fixed pips
        }
        else
        { // Fallback to ATR if Fixed SL is not used in MANUAL mode
            stopLossPoints = atrBuffer[0] * InpAtrSlMultiplier; // SL based on ATR multiplier // Corrected: Removed Point() multiplication here
        }

        stopLoss = (orderType==ORDER_TYPE_BUY) ?
                       entryPrice-stopLossPoints :
                       entryPrice+stopLossPoints;


    }
    else if(InpSLTPMethod == DONCHIAN_SLTP)
    { // Donchian Stop Loss
        //--- Donchian SL Logic - MODIFIED with ATR-like option ---
        if(InpUseDonchianAtrLikeSlTp)
        { // Use ATR-like Donchian SL/TP (SL adjusted by ATR)
            if(orderType==ORDER_TYPE_BUY)
            {
                stopLoss = donchianLowerBuffer[0]-(atrBuffer[0]*InpAtrSlMultiplier*0.5); // SL below Donchian Lower Band, ATR influenced
            }
            else
            {
                stopLoss = donchianUpperBuffer[0]+(atrBuffer[0]*InpAtrSlMultiplier*0.5); // SL above Donchian Upper Band, ATR influenced
            }
        }
        else
        { // Use original Donchian SL/TP (SL at Donchian band)
            if(orderType==ORDER_TYPE_BUY)
            {
                stopLoss = donchianLowerBuffer[0]; // SL at Donchian Lower Band (ORIGINAL)
            }
            else
            {
                stopLoss = donchianUpperBuffer[0]; // SL at Donchian Upper Band (ORIGINAL)
            }
        }
    }

    return((stopLoss!=0) ? NormalizeDouble(stopLoss,Digits()) : 0); // Normalize Stop Loss to symbol digits if not zero
}


//+------------------------------------------------------------------+
//| Calculate take profit level                                       |
//+------------------------------------------------------------------+
double CalculateTakeProfit(ENUM_ORDER_TYPE orderType, double entryPrice, double stopLoss, double highLevel, double lowLevel)
{
    double takeProfit = 0;

    if(InpSLTPMethod == ATR_SLTP)
    { // ATR Take Profit
        if(!InpUseAtrTP && !InpUseFixedTP) return(0); // If neither ATR TP nor Fixed TP is enabled, return 0 TP

        double takeProfitPoints;
        if(InpUseAtrTP)
        {
            takeProfitPoints = atrBuffer[0] * InpAtrTpMultiplier; // TP based on ATR multiplier
        }
        else
        {
            takeProfitPoints = InpFixedTPPips * Point(); // TP based on fixed pips
        }

        takeProfit = (orderType==ORDER_TYPE_BUY) ?
                       entryPrice+takeProfitPoints :
                       entryPrice-takeProfitPoints;


    }
    else if(InpSLTPMethod == MANUAL)
    { // Manual Fixed Take Profit
        if(!InpUseFixedTP && !InpUseAtrTP) return(0); // Prioritize Fixed TP if MANUAL method is selected, fallback to ATR if Fixed TP is disabled

        double takeProfitPoints;
        if(InpUseFixedTP)
        {
            takeProfitPoints = InpFixedTPPips * Point(); // TP based on fixed pips
        }
        else
        { // Fallback to ATR if Fixed TP is not used in MANUAL mode
            takeProfitPoints = atrBuffer[0] * InpAtrTpMultiplier; // TP based on ATR multiplier // Corrected: Removed Point() multiplication here
        }

        takeProfit = (orderType==ORDER_TYPE_BUY) ?
                       entryPrice+takeProfitPoints :
                       entryPrice-takeProfitPoints;

    }
    else if(InpSLTPMethod == DONCHIAN_SLTP)
    { // Donchian Take Profit
        //--- Donchian TP Logic - MODIFIED with ATR-like option ---
        if(InpUseDonchianAtrLikeSlTp)
        { // Use ATR-like Donchian TP (TP adjusted by ATR)
            if(orderType==ORDER_TYPE_BUY)
            {
                takeProfit = donchianUpperBuffer[0]+(atrBuffer[0]*InpAtrTpMultiplier*0.75); // TP above Donchian Upper Band, ATR influenced
            }
            else
            {
                takeProfit = donchianLowerBuffer[0]-(atrBuffer[0]*InpAtrTpMultiplier*0.75); // TP below Donchian Lower Band, ATR influenced
            }
        }
        else
        { // Use original Donchian TP (TP at Donchian band)
            if(orderType==ORDER_TYPE_BUY)
            {
                takeProfit = donchianUpperBuffer[0]; // TP at Donchian Upper Band (ORIGINAL)
            }
            else
            {
                takeProfit = donchianLowerBuffer[0]; // TP at Donchian Lower Band (ORIGINAL)
            }
        }
    }

    return((takeProfit!=0) ? NormalizeDouble(takeProfit,Digits()) : 0); // Normalize Take Profit to symbol digits if not zero
}


//+------------------------------------------------------------------+
//| Place pending order                                             |
//+------------------------------------------------------------------+
void PlacePendingOrder(ENUM_ORDER_TYPE orderType, double highLevel, double lowLevel)
{
    Print("PlacePendingOrder: Called for Order Type:", EnumToString(orderType));
    double volume = CalculatePositionSize(orderType); // Calculate position volume based on risk
    Print("PlacePendingOrder: Calculated Volume:", volume);
    if(volume <= 0)
    {
        Print("PlacePendingOrder: Invalid volume, exiting function");
        return;
    }

    //--- Check current spread against Max Spread ---
    double currentSpread = SymbolInfoDouble(Symbol(), SYMBOL_SPREAD); // Get current spread in points
    if(currentSpread > InpMaxSpread)
    {
        Print("PlacePendingOrder: Current spread (" + DoubleToString(currentSpread) + ") exceeds MaxSpread (" + IntegerToString(InpMaxSpread) + "). Order placing cancelled.");
        return; // Cancel order placement if spread is too high
    }
    Print("PlacePendingOrder: Current spread is acceptable (" + DoubleToString(currentSpread) + " points). MaxSpread limit: " + IntegerToString(InpMaxSpread) + " points.");


    double entryPrice = 0; // Variable to store entry price

    //--- Determine if previous HighLow candle is bullish or bearish based on Open and High prices
    bool isHighLowBullish = (highBuffer[1] > openHighLowBuffer[1]); // Bullish candle if High > Open

    //--- Determine entry price for Buy Stop and Sell Stop orders based on candle type
    if (orderType == ORDER_TYPE_BUY)
    {
        entryPrice = isHighLowBullish ? highBuffer[1] : openHighLowBuffer[1]; // Buy Stop at High if bullish, at Open if bearish
    }
    else
    { // ORDER_TYPE_SELL
        entryPrice = isHighLowBullish ? openHighLowBuffer[1] : lowBuffer[1];  // Sell Stop at Open if bullish, at Low if bearish
    }


    double stopLoss = CalculateStopLoss(orderType, entryPrice, highLevel, lowLevel); // Calculate Stop Loss level
    double takeProfit = CalculateTakeProfit(orderType, entryPrice, stopLoss, highLevel, lowLevel); // Calculate Take Profit level

    Print("PlacePendingOrder: Entry Price:", entryPrice, ", Stop Loss:", stopLoss, ", Take Profit:", takeProfit);

    //--- Set trade parameters for pending order placement
    trade.SetExpertMagicNumber(InpMagicNumber); // Set magic number to identify orders placed by this EA
    trade.SetDeviationInPoints(10);         // Set slippage/deviation for order execution

    //--- Execute the trade by placing a Pending Order (Buy Stop or Sell Stop)
    bool result = false;
    if(orderType == ORDER_TYPE_BUY)
    {
        result = trade.BuyStop(InpLots, entryPrice, Symbol(), stopLoss, takeProfit, ORDER_TIME_GTC, 0, InpTradeComment); // Place Buy Stop order // Corrected function parameters order
        Print("PlacePendingOrder: trade.BuyStop() called, result:", result);
    }
    else
    {
        result = trade.SellStop(InpLots, entryPrice, Symbol(), stopLoss, takeProfit, ORDER_TIME_GTC, 0, InpTradeComment); // Place Sell Stop order // Corrected function parameters order
        Print("PlacePendingOrder: trade.SellStop() called, result:", result);
    }

    //--- Check the result of pending order placement
    if(result)
    {
        if(trade.ResultRetcode() == TRADE_RETCODE_DONE)
        {
            Print("PlacePendingOrder: Pending order placed successfully. Ticket: ", trade.ResultOrder()); // Print order ticket if placed successfully
        }
        else
        {
            Print("PlacePendingOrder: Pending order placement failed. Error: ", trade.ResultRetcode()); // Print error code if placement failed
            HandleTradingError(trade.ResultRetcode()); // Call error handling function
        }
    }
    else
    {
        Print("PlacePendingOrder: trade.BuyStop()/trade.SellStop() returned FALSE (failed)"); // Print message if trade function returned false
    }
}


//+------------------------------------------------------------------+
//| Handle trailing stop and break even logic                        |
//+------------------------------------------------------------------+
void HandleTrailingStop()
{
    //--- Iterate through all open positions
    for (int i = PositionsTotal() - 1; i >= 0; i--)
    {
        long positionTicket = PositionGetTicket(i); // Get position ticket
        if (PositionSelectByTicket(positionTicket)) // Select position by ticket for further operations
        {
            //--- Check if position is for current symbol and magic number (to manage only EA's positions)
            if (PositionGetSymbol(positionTicket) == Symbol() && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber) // Corrected PositionSymbol and PositionMagic usage
            {
                ENUM_ORDER_TYPE orderType = PositionGetInteger(POSITION_TYPE); // Get order type (Buy or Sell)
                double currentPrice = (orderType == ORDER_TYPE_BUY) ? symbolInfo.Bid() : symbolInfo.Ask(); // Get current price based on order type
                double stopLossPrice = PositionGetDouble(POSITION_SL);    // Get current Stop Loss price
                double takeProfitPrice = PositionGetDouble(POSITION_TP);  // Get current Take Profit price
                double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);   // Get position open price
                double profitPips = (orderType == ORDER_TYPE_BUY) ? (currentPrice - entryPrice) / Point() : (entryPrice - currentPrice) / Point(); // Calculate profit in pips


                //--- Break Even Logic ---
                if (InpUseBreakEven) // Check if Break Even is enabled in input parameters
                {
                    if (profitPips >= InpBreakEvenPips && stopLossPrice < entryPrice) // Check if profit is >= BreakEvenPips and SL is not yet at break even
                    {
                        double breakEvenLevel = entryPrice + (InpBreakEvenPipsToLock * Point() * (orderType == ORDER_TYPE_BUY ? 1 : -1)); // Calculate break even level with lock-in pips
                        double newStopLossPrice = NormalizeDouble(breakEvenLevel, Digits()); // Normalize price to symbol digits

                        Print("HandleTrailingStop: " + EnumToString(orderType) + " - Break Even triggered. Modifying Stop Loss to ", newStopLossPrice);
                        trade.PositionModify(Symbol(), newStopLossPrice, takeProfitPrice); // Modify Stop Loss to break even level
                    }
                }


                //--- Trailing Stop Logic (if Break Even is not triggered or not used, then apply Trailing Stop)
                if (InpUseTrailingStop) // Check if Trailing Stop is enabled in input parameters
                {
                    if (orderType == ORDER_TYPE_BUY)
                    { // For Buy positions
                        double newStopLossPrice = NormalizeDouble(currentPrice - InpTrailingStopPips * Point(), Digits()); // Calculate new Trailing Stop Loss level
                        if (InpTrailingStopPips > 0 && currentPrice - entryPrice > InpTrailingStopPips * Point() && newStopLossPrice > stopLossPrice) // Check Trailing Stop conditions
                        {
                            if (InpTrailingStepPips <= 0 || newStopLossPrice >= stopLossPrice + InpTrailingStepPips * Point()) // Apply Trailing Step if defined
                            {
                                Print("HandleTrailingStop: BUY - Modifying Trailing Stop Loss from ", stopLossPrice, " to ", newStopLossPrice);
                                trade.PositionModify(Symbol(), newStopLossPrice, takeProfitPrice); // Modify Stop Loss to new trailing level
                            }
                        }
                    }
                    else if (orderType == ORDER_TYPE_SELL)
                    { // For Sell positions
                        double newStopLossPrice = NormalizeDouble(currentPrice + InpTrailingStopPips * Point(), Digits()); // Calculate new Trailing Stop Loss level
                        if (InpTrailingStopPips > 0 && entryPrice - currentPrice > InpTrailingStopPips * Point() && newStopLossPrice < stopLossPrice) // Check Trailing Stop conditions
                        {
                            if (InpTrailingStepPips <= 0 || newStopLossPrice <= stopLossPrice - InpTrailingStepPips * Point()) // Apply Trailing Step if defined
                            {
                                Print("HandleTrailingStop: SELL - Modifying Trailing Stop Loss from ", stopLossPrice, " to ", newStopLossPrice);
                                trade.PositionModify(Symbol(), newStopLossPrice, takeProfitPrice); // Modify Stop Loss to new trailing level
                            }
                        }
                    }
                }
            }
        }
    }
}


//+------------------------------------------------------------------+
//| Handle trading errors                                           |
//+------------------------------------------------------------------+
void HandleTradingError(int errorCode)
{
    Print("HandleTradingError: Trading Error Code: ", errorCode, " - ", ErrorDescription(errorCode));
    //--- Implement error handling logic here if needed (e.g., logging, notification, etc.) ---
    switch(errorCode)
    {
        case TRADE_RETCODE_REJECT:
        case TRADE_RETCODE_CANCEL:
            Print("HandleTradingError: Order rejected or cancelled by broker.");
            //--- Add specific handling for order rejection/cancellation if needed ---
            break;
        case TRADE_RETCODE_NO_MONEY:
            Print("HandleTradingError: Insufficient funds to place order.");
            //--- Add specific handling for insufficient funds if needed ---
            break;
        //--- Add cases for other common trading errors if needed ---
        default:
            Print("HandleTradingError: Unhandled trading error code.");
            //--- Default error handling ---
            break;
    }
}

//+------------------------------------------------------------------+
//| Get Deinitialization Reason String                                |
//+------------------------------------------------------------------+
string GetDeinitReasonString(const int reason)
{
    switch(reason)
    {
        case REASON_PROGRAM:        return("Account re-initialization"); // Corrected to "Account re-initialization" as it's more descriptive for PROGRAM reason in MQL5
        case REASON_REMOVE:         return("Chart symbol or period changed"); // Corrected to "Chart symbol or period changed" as it's more descriptive for REMOVE reason in MQL5
        case REASON_RECOMPILE:      return("Chart closed"); // Corrected to "Chart closed" as it's more descriptive for RECOMPILE reason in MQL5
        case REASON_CHARTCHANGE:    return("Program compilation"); // Corrected to "Program compilation" as it's more descriptive for CHARTCHANGE reason in MQL5
        case REASON_PARAMETERS:     return("Input parameters changed");
        case REASON_ACCOUNT:        return("Template changed"); // Corrected to "Template changed" as it's more descriptive for ACCOUNT reason in MQL5
        case REASON_TEMPLATE:       return("Expert Advisor, script or indicator changed"); // Corrected to "Expert Advisor, script or indicator changed" as it's more descriptive for TEMPLATE reason in MQL5
        case REASON_INITFAILED:     return("Expert Advisor, script or indicator removed"); // Corrected to "Expert Advisor, script or indicator removed" as it's more descriptive for INITFAILED reason in MQL5
        default:                    return("Unknown reason");
    }
}


//+------------------------------------------------------------------+
//| Is New Bar on Timeframe                                           |
//+------------------------------------------------------------------+
bool IsNewBar(ENUM_TIMEFRAMES timeframe)
{
    static datetime lastBarTime = 0; // Static variable to store the time of the last processed bar
    datetime currentBarTime = iTime(Symbol(), timeframe, 0); // Get current bar time for the given timeframe

    //--- Check if current bar time is greater than the last bar time
    if(currentBarTime > lastBarTime)
    {
        lastBarTime = currentBarTime; // Update last bar time to current bar time
        return(true);                  // Return true if new bar is detected
    }
    return(false);                     // Return false if it's not a new bar
}
//+------------------------------------------------------------------+
