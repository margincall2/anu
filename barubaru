//+------------------------------------------------------------------+
//| Sakha Property with Donchian Channel Filter                        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Sakha"
#property link      "https://shopee.co.id/algotrade"
#property version   "1.02"
#property description "Sakha Property with Donchian Channel Filter with Commission"
#property strict

// Cache frequently used string constant
#define ORDER_COMMENT_CONST "HLStrategy_DC"

//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
// Trading Parameters
input ulong   MagicNumber = 123456;          // Magic Number
input double  LotSize = 0.1;                 // Lot Size (Initial)
input double  RiskPercent = 1.0;             // Risk per trade (%)
input string  OrderComment = ORDER_COMMENT_CONST; // Order Comment
input double  Commission = 3.0;              // Commission per trade

// Risk Management Parameters
input int     StopLoss = 50;                 // Stop Loss (points)
input int     TakeProfit = 100;              // Take Profit (points)
input int     TrailingStop = 20;             // Trailing Stop (points)
input int     BreakEven = 10;                // Break Even (points)
input int     MaxSpread = 10;                // Max Allowed Spread

// Timeframe Settings
input ENUM_TIMEFRAMES Timeframe = PERIOD_CURRENT;      // Trading Timeframe
input ENUM_TIMEFRAMES DonchianTimeframe = PERIOD_W1;   // Donchian Timeframe
input int             DonchianPeriod = 20;            // Donchian Period

//+------------------------------------------------------------------+
//| Global Variables - Cached Values                                   |
//+------------------------------------------------------------------+
static datetime lastBarTime = 0;
static double currentHigh = 0.0;
static double currentLow = 0.0;
static double tickValue = 0.0;
static double minLot = 0.0;
static double maxLot = 0.0;
static string currentSymbol = "";
static double pointValue = 0.0;
static double commissionPerLot = 0.0;

//+------------------------------------------------------------------+
//| Struct Definition                                                  |
//+------------------------------------------------------------------+
struct DonchianLevels {
    double upperBand;
    double lowerBand;
};

// Pre-allocated trade objects
static MqlTradeRequest request;
static MqlTradeResult result;
static DonchianLevels g_donchian;

//+------------------------------------------------------------------+
//| Expert Initialization Function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize cached values only once
    currentSymbol = Symbol();
    tickValue = SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE);
    minLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MIN);
    maxLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MAX);
    pointValue = _Point;
    commissionPerLot = Commission / (LotSize * 100000);

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert Tick Function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
    if(!CheckSpread()) return;

    if(IsNewBar())
    {
        UpdateLevels();
        DonchianLevels localDonchian = CalculateDonchianChannel(DonchianTimeframe, DonchianPeriod);
        ManagePendingOrders(localDonchian);
    }

    ManageOpenPositions();
}

//+------------------------------------------------------------------+
//| Trading Condition Functions                                        |
//+------------------------------------------------------------------+
bool CheckSpread()
{
    if((int)SymbolInfoInteger(currentSymbol, SYMBOL_SPREAD) > MaxSpread)
    {
        CancelAllPending();
        return false;
    }
    return true;
}

//+------------------------------------------------------------------+
//| Bar Management Functions                                           |
//+------------------------------------------------------------------+
inline bool IsNewBar()
{
    datetime currentBarTime = iTime(currentSymbol, Timeframe, 0);
    if(currentBarTime != lastBarTime)
    {
        lastBarTime = currentBarTime;
        return true;
    }
    return false;
}

inline void UpdateLevels()
{
    currentHigh = iHigh(currentSymbol, Timeframe, 1);
    currentLow = iLow(currentSymbol, Timeframe, 1);
}

//+------------------------------------------------------------------+
//| Donchian Channel Calculations                                      |
//+------------------------------------------------------------------+
DonchianLevels CalculateDonchianChannel(const ENUM_TIMEFRAMES donchianTF, const int donchianPeriod)
{
    DonchianLevels levels;
    const int barsToCount = (donchianPeriod <= 0) ? 20 : donchianPeriod;
    
    static double highArray[], lowArray[];
    ArrayResize(highArray, barsToCount);
    ArrayResize(lowArray, barsToCount);
    ArraySetAsSeries(highArray, true);
    ArraySetAsSeries(lowArray, true);

    CopyHigh(currentSymbol, donchianTF, 1, barsToCount, highArray);
    CopyLow(currentSymbol, donchianTF, 1, barsToCount, lowArray);

    levels.upperBand = highArray[ArrayMaximum(highArray, 0, barsToCount)];
    levels.lowerBand = lowArray[ArrayMinimum(lowArray, 0, barsToCount)];

    return levels;
}

//+------------------------------------------------------------------+
//| Order Management Functions                                         |
//+------------------------------------------------------------------+
void ManagePendingOrders(const DonchianLevels &donchian)
{
    bool buyStopFound = false, sellStopFound = false;
    ulong buyTicket = 0, sellTicket = 0;

    const double effectiveUpperBand = donchian.upperBand + commissionPerLot;
    const double effectiveLowerBand = donchian.lowerBand - commissionPerLot;
    const double bodyHigh = MathMax(iOpen(currentSymbol, Timeframe, 1), iClose(currentSymbol, Timeframe, 1));
    const double bodyLow = MathMin(iOpen(currentSymbol, Timeframe, 1), iClose(currentSymbol, Timeframe, 1));

    // Process existing orders
    const int totalOrders = OrdersTotal();
    for(int i = totalOrders - 1; i >= 0; i--)
    {
        const ulong ticket = OrderGetTicket(i);
        if(ticket <= 0) continue;

        if(OrderGetInteger(ORDER_MAGIC) == MagicNumber &&
           OrderGetString(ORDER_COMMENT) == OrderComment)
        {
            const ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if(type == ORDER_TYPE_BUY_STOP)
            {
                buyStopFound = true;
                buyTicket = ticket;
                CheckModifyOrder(buyTicket, bodyHigh, ORDER_TYPE_BUY_STOP);
            }
            else if(type == ORDER_TYPE_SELL_STOP)
            {
                sellStopFound = true;
                sellTicket = ticket;
                CheckModifyOrder(sellTicket, bodyLow, ORDER_TYPE_SELL_STOP);
            }
        }
    }

    const bool buySignal = currentHigh > effectiveUpperBand;
    const bool sellSignal = currentLow < effectiveLowerBand;

    if(buySignal)
    {
        if(!buyStopFound) PlacePendingOrder(ORDER_TYPE_BUY_STOP, bodyHigh);
        if(!sellStopFound) PlacePendingOrder(ORDER_TYPE_SELL_STOP, bodyLow);
    }
    else if(sellSignal)
    {
        if(!sellStopFound) PlacePendingOrder(ORDER_TYPE_SELL_STOP, bodyLow);
        if(!buyStopFound) PlacePendingOrder(ORDER_TYPE_BUY_STOP, bodyHigh);
    }
    else
    {
        CancelAllPending();
    }
}

bool CheckModifyOrder(const ulong ticket, const double newPrice, const ENUM_ORDER_TYPE type)
{
    if(ticket <= 0) return false;
    
    const double currentPrice = OrderGetDouble(ORDER_PRICE_OPEN);
    if(currentPrice == newPrice) return true;

    const double commissionInPoints = Commission / (LotSize * tickValue);

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_MODIFY;
    request.order = ticket;
    request.price = newPrice;
    request.sl = (type == ORDER_TYPE_BUY_STOP) ?
                newPrice - (StopLoss + commissionInPoints) * pointValue :
                newPrice + (StopLoss + commissionInPoints) * pointValue;
    request.tp = (type == ORDER_TYPE_BUY_STOP) ?
                newPrice + (TakeProfit - commissionInPoints) * pointValue :
                newPrice - (TakeProfit - commissionInPoints) * pointValue;

    return OrderSend(request, result);
}

bool PlacePendingOrder(const ENUM_ORDER_TYPE type, const double price)
{
    const double commissionInPoints = Commission / (LotSize * tickValue);

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_PENDING;
    request.symbol = currentSymbol;
    request.volume = CalculateLotSize();
    request.type = type;
    request.price = price;
    request.sl = (type == ORDER_TYPE_BUY_STOP) ?
                price - (StopLoss + commissionInPoints) * pointValue :
                price + (StopLoss + commissionInPoints) * pointValue;
    request.tp = (type == ORDER_TYPE_BUY_STOP) ?
                price + (TakeProfit - commissionInPoints) * pointValue :
                price - (TakeProfit - commissionInPoints) * pointValue;
    request.deviation = 5;
    request.magic = MagicNumber;
    request.comment = OrderComment;

    return OrderSend(request, result);
}

//+------------------------------------------------------------------+
//| Position Management Functions                                      |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
    UpdateLevels();

    const int totalPositions = PositionsTotal();
    for(int i = totalPositions - 1; i >= 0; i--)
    {
        const ulong ticket = PositionGetTicket(i);
        if(ticket <= 0) continue;

        if(PositionGetInteger(POSITION_MAGIC) == MagicNumber &&
           PositionGetString(POSITION_COMMENT) == OrderComment)
        {
            ManagePosition(ticket);
        }
    }
}

void ManagePosition(const ulong ticket)
{
    if(ticket <= 0) return;

    const ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    const double currentPrice = (type == POSITION_TYPE_BUY) ?
                              SymbolInfoDouble(currentSymbol, SYMBOL_BID) :
                              SymbolInfoDouble(currentSymbol, SYMBOL_ASK);
    const double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    const double currentSl = PositionGetDouble(POSITION_SL);
    const double commissionInPoints = Commission / (LotSize * tickValue);
    const double pointsProfit = (MathAbs(currentPrice - openPrice) / pointValue) - commissionInPoints;

    const bool isAtBreakeven = (type == POSITION_TYPE_BUY && currentSl >= openPrice) ||
                              (type == POSITION_TYPE_SELL && currentSl <= openPrice);

    if(!isAtBreakeven && pointsProfit >= BreakEven)
    {
        const double newSl = openPrice + (type == POSITION_TYPE_BUY ?
                            (1 + commissionInPoints) * pointValue :
                            (-1 - commissionInPoints) * pointValue);
        ModifyPositionSl(ticket, newSl);
    }
    else if(isAtBreakeven && pointsProfit >= TrailingStop)
    {
        const double newSl = currentPrice - (type == POSITION_TYPE_BUY ?
                            (TrailingStop + commissionInPoints) * pointValue :
                            -(TrailingStop + commissionInPoints) * pointValue);

        if((type == POSITION_TYPE_BUY && newSl > currentSl) ||
           (type == POSITION_TYPE_SELL && newSl < currentSl))
        {
            ModifyPositionSl(ticket, newSl);
        }
    }
}

bool ModifyPositionSl(const ulong ticket, const double newSl)
{
    if(ticket <= 0) return false;

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol = currentSymbol;
    request.sl = newSl;
    request.tp = PositionGetDouble(POSITION_TP);

    return OrderSend(request, result);
}

//+------------------------------------------------------------------+
//| Utility Functions                                                  |
//+------------------------------------------------------------------+
inline double CalculateLotSize()
{
    const double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    const double risk_amount = balance * RiskPercent / 100.0;
    const double totalRiskPerPoint = StopLoss * tickValue + Commission;
    double lotSize = NormalizeDouble(risk_amount / totalRiskPerPoint, 2);

    return MathMin(MathMax(lotSize, minLot), maxLot);
}

void CancelAllPending()
{
    const int totalOrders = OrdersTotal();
    for(int i = totalOrders - 1; i >= 0; i--)
    {
        const ulong ticket = OrderGetTicket(i);
        if(ticket <= 0) continue;

        if(OrderGetInteger(ORDER_MAGIC) == MagicNumber &&
           OrderGetString(ORDER_COMMENT) == OrderComment)
        {
            CancelOrder(ticket);
        }
    }
}

bool CancelOrder(const ulong ticket)
{
    if(ticket <= 0) return false;

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_REMOVE;
    request.order = ticket;

    return OrderSend(request, result);
}
//+------------------------------------------------------------------+