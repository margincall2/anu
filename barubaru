//+------------------------------------------------------------------+
//| Sakha Property with Donchian Channel Filter                        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Sakha"
#property link      "https://shopee.co.id/algotrade"
#property version   "1.02"
#property description "Sakha Property with Donchian Channel Filter with Commission"

// Cache frequently used string constant
#define ORDER_COMMENT_CONST "HLStrategy_DC"

//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
// Trading Parameters
input ulong   MagicNumber = 123456;          // Magic Number
input double  LotSize = 0.1;                 // Lot Size (Initial)
input double  RiskPercent = 1.0;             // Risk per trade (%)
input string  OrderComment = ORDER_COMMENT_CONST; // Order Comment
input double  Commission = 3.0;              // Commission per trade

// Risk Management Parameters
input int     StopLoss = 50;                 // Stop Loss (points)
input int     TakeProfit = 100;              // Take Profit (points)
input int     TrailingStop = 20;             // Trailing Stop (points)
input int     BreakEven = 10;                // Break Even (points)
input int     MaxSpread = 10;                // Max Allowed Spread

// Timeframe Settings
input ENUM_TIMEFRAMES Timeframe = PERIOD_CURRENT;      // Trading Timeframe
input ENUM_TIMEFRAMES DonchianTimeframe = PERIOD_W1;   // Donchian Timeframe
input int             DonchianPeriod = 20;            // Donchian Period

//+------------------------------------------------------------------+
//| Global Variables - Cached Values                                   |
//+------------------------------------------------------------------+
datetime lastBarTime;                // Last processed bar time
double currentHigh;                 // Current bar high
double currentLow;                  // Current bar low
double tickValue;                   // Cached tick value
double minLot;                      // Minimum lot size
double maxLot;                      // Maximum lot size
string currentSymbol;               // Current symbol
double pointValue;                  // Point value

//+------------------------------------------------------------------+
//| Struct Definition                                                  |
//+------------------------------------------------------------------+
struct DonchianLevels {
    double upperBand;
    double lowerBand;
};

//+------------------------------------------------------------------+
//| Expert Initialization Function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize cached values
    lastBarTime = 0;
    currentSymbol = Symbol();
    tickValue = SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE);
    minLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MIN);
    maxLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MAX);
    pointValue = _Point;

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert Tick Function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
    if(!CheckSpread()) return;

    if(IsNewBar())
    {
        static DonchianLevels donchian;
        UpdateLevels();
        donchian = CalculateDonchianChannel(DonchianTimeframe, DonchianPeriod);
        ManagePendingOrders(donchian);
    }

    ManageOpenPositions();
}

//+------------------------------------------------------------------+
//| Trading Condition Functions                                        |
//+------------------------------------------------------------------+
bool CheckSpread()
{
    static int spread;
    spread = (int)SymbolInfoInteger(currentSymbol, SYMBOL_SPREAD);

    if(spread > MaxSpread)
    {
        CancelAllPending();
        return false;
    }
    return true;
}

//+------------------------------------------------------------------+
//| Bar Management Functions                                           |
//+------------------------------------------------------------------+
bool IsNewBar()
{
    datetime currentBarTime = iTime(currentSymbol, Timeframe, 0);
    if(currentBarTime != lastBarTime)
    {
        lastBarTime = currentBarTime;
        return true;
    }
    return false;
}

void UpdateLevels()
{
    currentHigh = iHigh(currentSymbol, Timeframe, 1);
    currentLow = iLow(currentSymbol, Timeframe, 1);
}

//+------------------------------------------------------------------+
//| Donchian Channel Calculations                                      |
//+------------------------------------------------------------------+
DonchianLevels CalculateDonchianChannel(const ENUM_TIMEFRAMES donchianTF, const int donchianPeriod)
{
    DonchianLevels levels;
    const int barsToCount = (donchianPeriod <= 0) ? 20 : donchianPeriod;
    const int startBar = 1;

    double highArray[], lowArray[];
    ArraySetAsSeries(highArray, true);
    ArraySetAsSeries(lowArray, true);

    CopyHigh(currentSymbol, donchianTF, startBar, barsToCount, highArray);
    CopyLow(currentSymbol, donchianTF, startBar, barsToCount, lowArray);

    levels.upperBand = highArray[ArrayMaximum(highArray, 0, barsToCount)];
    levels.lowerBand = lowArray[ArrayMinimum(lowArray, 0, barsToCount)];

    return levels;
}

//+------------------------------------------------------------------+
//| Order Management Functions                                         |
//+------------------------------------------------------------------+
void ManagePendingOrders(const DonchianLevels &donchian)
{
    bool buyStopFound = false, sellStopFound = false;
    ulong buyTicket = 0, sellTicket = 0;

    // Pre-calculate commission adjustments
    const double commissionAdjustment = Commission / (LotSize * 100000);
    const double effectiveUpperBand = donchian.upperBand + commissionAdjustment;
    const double effectiveLowerBand = donchian.lowerBand - commissionAdjustment;

    // Get body high and low of the previous candle
    double bodyHigh = MathMax(iOpen(currentSymbol, Timeframe, 1), iClose(currentSymbol, Timeframe, 1));
    double bodyLow = MathMin(iOpen(currentSymbol, Timeframe, 1), iClose(currentSymbol, Timeframe, 1));

    const int totalOrders = OrdersTotal();
    for (int i = totalOrders - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if (ticket <= 0) continue;

        if (OrderGetInteger(ORDER_MAGIC) == MagicNumber &&
            OrderGetString(ORDER_COMMENT) == OrderComment)
        {
            ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if (type == ORDER_TYPE_BUY_STOP)
            {
                buyStopFound = true;
                buyTicket = ticket;
                CheckModifyOrder(buyTicket, bodyHigh, ORDER_TYPE_BUY_STOP); // Tetap modify ke bodyHigh
            }
            else if (type == ORDER_TYPE_SELL_STOP)
            {
                sellStopFound = true;
                sellTicket = ticket;
                CheckModifyOrder(sellTicket, bodyLow, ORDER_TYPE_SELL_STOP); // Tetap modify ke bodyLow
            }
        }
    }

    // Check for signals and manage orders
    bool buySignal = currentHigh > effectiveUpperBand;
    bool sellSignal = currentLow < effectiveLowerBand;

    if (buySignal)
    {
        if (!buyStopFound)
        {
            Print("Placing Buy Stop at Body High: ", bodyHigh);
            PlacePendingOrder(ORDER_TYPE_BUY_STOP, bodyHigh); // Buy Stop di bodyHigh
        }
        if (!sellStopFound)
        {
            Print("Placing Sell Stop at Body Low: ", bodyLow);
            PlacePendingOrder(ORDER_TYPE_SELL_STOP, bodyLow); // Sell Stop di bodyLow (saat sinyal BELI)
        }
    }
    else if (sellSignal)
    {
        if (!sellStopFound)
        {
            Print("Placing Sell Stop at Body Low: ", bodyLow);
            PlacePendingOrder(ORDER_TYPE_SELL_STOP, bodyLow); // Sell Stop di bodyLow
        }
        if (!buyStopFound)
        {
            Print("Placing Buy Stop at Body High: ", bodyHigh);
            PlacePendingOrder(ORDER_TYPE_BUY_STOP, bodyHigh); // Buy Stop di bodyHigh (saat sinyal JUAL)
        }
    }
    else
    {
        CancelAllPending();
    }
}

void CheckModifyOrder(const ulong ticket, const double newPrice, const ENUM_ORDER_TYPE type)
{
    const double currentPrice = OrderGetDouble(ORDER_PRICE_OPEN);
    if(currentPrice == newPrice) return;

    const double commissionInPoints = Commission / (LotSize * tickValue);

    const double sl = (type == ORDER_TYPE_BUY_STOP) ?
                newPrice - (StopLoss + commissionInPoints) * pointValue :
                newPrice + (StopLoss + commissionInPoints) * pointValue;

    const double tp = (type == ORDER_TYPE_BUY_STOP) ?
                newPrice + (TakeProfit - commissionInPoints) * pointValue :
                newPrice - (TakeProfit - commissionInPoints) * pointValue;

    static MqlTradeRequest request;
    static MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_MODIFY;
    request.order = ticket;
    request.price = newPrice;
    request.sl = sl;
    request.tp = tp;

    if(!OrderSend(request, result))
    {
        Print("OrderModify failed. Error code: ", result.retcode);
    }
}

void PlacePendingOrder(const ENUM_ORDER_TYPE type, const double price)
{
    const double commissionInPoints = Commission / (LotSize * tickValue);

    const double sl = (type == ORDER_TYPE_BUY_STOP) ?
                price - (StopLoss + commissionInPoints) * pointValue :
                price + (StopLoss + commissionInPoints) * pointValue;

    const double tp = (type == ORDER_TYPE_BUY_STOP) ?
                price + (TakeProfit - commissionInPoints) * pointValue :
                price - (TakeProfit - commissionInPoints) * pointValue;

    static MqlTradeRequest request;
    static MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_PENDING;
    request.symbol = currentSymbol;
    request.volume = CalculateLotSize();
    request.type = type;
    request.price = price;
    request.sl = sl;
    request.tp = tp;
    request.deviation = 5;
    request.magic = MagicNumber;
    request.comment = OrderComment;

    if(!OrderSend(request, result))
    {
        Print("OrderSend failed. Error code: ", result.retcode);
    }
}

//+------------------------------------------------------------------+
//| Position Management Functions                                      |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
    UpdateLevels();

    const int totalPositions = PositionsTotal();
    for (int i = totalPositions - 1; i >= 0; i--)
    {
        const ulong ticket = PositionGetTicket(i);
        if (ticket <= 0) continue;

        if (PositionGetInteger(POSITION_MAGIC) == MagicNumber &&
            PositionGetString(POSITION_COMMENT) == OrderComment)
        {
            ManagePosition(ticket);
        }
    }
}

void ManagePosition(const ulong ticket)
{
    const ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    const double currentPrice = (type == POSITION_TYPE_BUY) ?
                              SymbolInfoDouble(currentSymbol, SYMBOL_BID) :
                              SymbolInfoDouble(currentSymbol, SYMBOL_ASK);
    const double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    const double currentSl = PositionGetDouble(POSITION_SL);

    const double commissionInPoints = Commission / (LotSize * tickValue);
    const double pointsProfit = (MathAbs(currentPrice - openPrice) / pointValue) - commissionInPoints;

    const bool isAtBreakeven = (type == POSITION_TYPE_BUY && currentSl >= openPrice) ||
                              (type == POSITION_TYPE_SELL && currentSl <= openPrice);

    if (!isAtBreakeven && pointsProfit >= BreakEven)
    {
        const double newSl = openPrice + (type == POSITION_TYPE_BUY ?
                            (1 + commissionInPoints) * pointValue :
                            (-1 - commissionInPoints) * pointValue);
        ModifyPositionSl(ticket, newSl);
    }
    else if (isAtBreakeven && pointsProfit >= TrailingStop)
    {
        const double newSl = currentPrice - (type == POSITION_TYPE_BUY ?
                            (TrailingStop + commissionInPoints) * pointValue :
                            -(TrailingStop + commissionInPoints) * pointValue);

        if ((type == POSITION_TYPE_BUY && newSl > currentSl) ||
           (type == POSITION_TYPE_SELL && newSl < currentSl))
        {
            ModifyPositionSl(ticket, newSl);
        }
    }
}

void ModifyPositionSl(const ulong ticket, const double newSl)
{
    static MqlTradeRequest request;
    static MqlTradeResult result;
    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol = currentSymbol;
    request.sl = newSl;
    request.tp = PositionGetDouble(POSITION_TP);

    if(!OrderSend(request, result))
    {
        Print("ModifyPositionSL failed. Error code: ", result.retcode);
    }
}

//+------------------------------------------------------------------+
//| Utility Functions                                                  |
//+------------------------------------------------------------------+
double CalculateLotSize()
{
    static double lotSize;
    const double balance = AccountInfoDouble(ACCOUNT_BALANCE);

    const double risk_amount = balance * RiskPercent / 100.0;
    const double totalRiskPerPoint = StopLoss * tickValue + Commission;
    lotSize = NormalizeDouble(risk_amount / totalRiskPerPoint, 2);

    if(lotSize < minLot) lotSize = minLot;
    if(lotSize > maxLot) lotSize = maxLot;

    return lotSize;
}

void CancelAllPending()
{
    static MqlTradeRequest request;
    static MqlTradeResult result;

    const int totalOrders = OrdersTotal();
    for (int i = totalOrders - 1; i >= 0; i--)
    {
        const ulong ticket = OrderGetTicket(i);
        if (ticket <= 0) continue;

        if (OrderGetInteger(ORDER_MAGIC) == MagicNumber &&
            OrderGetString(ORDER_COMMENT) == OrderComment)
        {
            ZeroMemory(request);
            ZeroMemory(result);

            request.action = TRADE_ACTION_REMOVE;
            request.order = ticket;

            if(!OrderSend(request, result))
            {
                Print("OrderCancel failed. Error code: ", result.retcode);
            }
        }
    }
}
//+------------------------------------------------------------------+
