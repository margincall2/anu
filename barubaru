//+------------------------------------------------------------------+
//| Sakha Break V3 - Universal Pair Support                            |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Sakha"
#property link      "https://shopee.co.id/algotrade"
#property version   "3.00"
#property strict

#include <Trade/Trade.mqh>

//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
input group "Trading Parameters"
input ulong   MagicNumber    = 123456;          // Magic Number
input double  LotSize        = 0.1;             // Lot Size
input double  RiskPercent    = 1.0;             // Risk Percent (%)
input string  OrderComment   = "SakhaBreak_V3"; // Order Comment
input double  Commission     = 3.0;             // Commission per trade

input group "Risk Management"
input int     StopLoss       = 50;              // Stop Loss (points)
input int     TakeProfit     = 100;             // Take Profit (points)
input int     TrailingStop   = 20;              // Trailing Stop (points)
input int     BreakEven      = 10;              // Break Even (points)
input int     MaxSpread      = 10;              // Max Allowed Spread (points)

input group "Timeframe Settings"
input ENUM_TIMEFRAMES Timeframe         = PERIOD_CURRENT; // Trading Timeframe
input ENUM_TIMEFRAMES DonchianTimeframe = PERIOD_W1;     // Donchian Timeframe
input int             DonchianPeriod    = 20;            // Donchian Period

//+------------------------------------------------------------------+
//| Global Variables                                                   |
//+------------------------------------------------------------------+
datetime    g_lastBarTime    = 0;
double      g_pointValue     = 0.0;
double      g_adjustedPoint  = 0.0;
int         g_digits         = 0;
CTrade      trade;          // Object for trading operations

//+------------------------------------------------------------------+
//| Struct for Donchian Channel                                        |
//+------------------------------------------------------------------+
struct DonchianLevels 
{
   double upperBand;
   double lowerBand;
};

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   // Initialize symbol-specific values
   g_digits = (int)SymbolInfoInteger(Symbol(), SYMBOL_DIGITS);
   g_adjustedPoint = NormalizeDouble(SymbolInfoDouble(Symbol(), SYMBOL_POINT), g_digits);
   
   // Adjust point value for 3/5 digit pairs
   g_pointValue = (g_digits == 3 || g_digits == 5) ? g_adjustedPoint * 10.0 : g_adjustedPoint;
   
   // Initialize trade object
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(5);
   trade.SetTypeFilling(ORDER_FILLING_FOK);
   
   // Log initialization details
   PrintFormat("Symbol: %s, Digits: %d, Point: %.8f, PointValue: %.8f", 
               Symbol(), g_digits, g_adjustedPoint, g_pointValue);
               
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!CheckMarketConditions()) return;
   
   if(IsNewBar())
   {
      ManagePendingOrders();
   }
   
   ManageOpenPositions();
}

//+------------------------------------------------------------------+
//| Market condition checking                                          |
//+------------------------------------------------------------------+
bool CheckMarketConditions()
{
   double currentSpread = SymbolInfoDouble(Symbol(), SYMBOL_ASK) - SymbolInfoDouble(Symbol(), SYMBOL_BID);
   currentSpread = NormalizeDouble(currentSpread / g_pointValue, 1);
   
   if(currentSpread > MaxSpread)
   {
      DeletePendingOrders();
      return false;
   }
   return true;
}

//+------------------------------------------------------------------+
//| New bar detection                                                  |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   datetime currentBarTime = iTime(Symbol(), Timeframe, 0);
   if(currentBarTime != g_lastBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Calculate Donchian Channel levels                                  |
//+------------------------------------------------------------------+
DonchianLevels CalculateDonchianChannel()
{
   DonchianLevels levels;
   
   double highestHigh = iHigh(Symbol(), DonchianTimeframe, iHighest(Symbol(), DonchianTimeframe, MODE_HIGH, DonchianPeriod, 1));
   double lowestLow = iLow(Symbol(), DonchianTimeframe, iLowest(Symbol(), DonchianTimeframe, MODE_LOW, DonchianPeriod, 1));
   
   levels.upperBand = NormalizeDouble(highestHigh, g_digits);
   levels.lowerBand = NormalizeDouble(lowestLow, g_digits);
   
   return levels;
}

//+------------------------------------------------------------------+
//| Manage pending orders                                             |
//+------------------------------------------------------------------+
void ManagePendingOrders()
{
   DonchianLevels levels = CalculateDonchianChannel();
   double commissionAdjustment = GetCommissionInPoints() * g_pointValue;
   
   double upperEntry = NormalizeDouble(levels.upperBand + commissionAdjustment, g_digits);
   double lowerEntry = NormalizeDouble(levels.lowerBand - commissionAdjustment, g_digits);
   
   bool buyExists = false, sellExists = false;
   
   // Check existing orders
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      ulong ticket = OrderGetTicket(i);
      if(ticket <= 0) continue;
      
      if(OrderGetInteger(ORDER_MAGIC) == MagicNumber && 
         OrderGetString(ORDER_SYMBOL) == Symbol())
      {
         ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
         if(orderType == ORDER_TYPE_BUY_STOP)
            buyExists = true;
         else if(orderType == ORDER_TYPE_SELL_STOP)
            sellExists = true;
      }
   }
   
   // Place new orders if needed
   if(!buyExists) 
      PlaceOrder(ORDER_TYPE_BUY_STOP, upperEntry);
   if(!sellExists) 
      PlaceOrder(ORDER_TYPE_SELL_STOP, lowerEntry);
}

//+------------------------------------------------------------------+
//| Calculate commission in points                                     |
//+------------------------------------------------------------------+
double GetCommissionInPoints()
{
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   if(tickValue <= 0) tickValue = 0.1;
   
   return NormalizeDouble(Commission / (LotSize * tickValue), 1);
}

//+------------------------------------------------------------------+
//| Place new order                                                   |
//+------------------------------------------------------------------+
void PlaceOrder(const ENUM_ORDER_TYPE type, const double price)
{
   double volume = CalculateLotSize();
   double commissionPoints = GetCommissionInPoints() * g_pointValue;
   
   double sl = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(price - (StopLoss * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(price + (StopLoss * g_pointValue) + commissionPoints, g_digits);
               
   double tp = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(price + (TakeProfit * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(price - (TakeProfit * g_pointValue) + commissionPoints, g_digits);
   
   trade.OrderOpen(Symbol(), type, volume, 0, price, sl, tp, ORDER_TIME_GTC, 0, OrderComment);
}

//+------------------------------------------------------------------+
//| Calculate position size                                            |
//+------------------------------------------------------------------+
double CalculateLotSize()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   if(tickValue <= 0) tickValue = 0.1;

   double riskAmount = balance * RiskPercent / 100.0;
   double totalRisk = (StopLoss * tickValue) + Commission;
   
   double lotSize = NormalizeDouble(riskAmount / totalRisk, 2);
   
   double minLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);
   
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Manage open positions                                             |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber &&
         PositionGetString(POSITION_SYMBOL) == Symbol())
      {
         ManagePosition(ticket);
      }
   }
}

//+------------------------------------------------------------------+
//| Manage individual position                                         |
//+------------------------------------------------------------------+
void ManagePosition(const ulong ticket)
{
   if(!PositionSelectByTicket(ticket)) return;
   
   ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   double currentPrice = (type == POSITION_TYPE_BUY) ? 
                        SymbolInfoDouble(Symbol(), SYMBOL_BID) : 
                        SymbolInfoDouble(Symbol(), SYMBOL_ASK);
                        
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSL = PositionGetDouble(POSITION_SL);
   
   double commissionPoints = GetCommissionInPoints() * g_pointValue;
   double pointsProfit = (MathAbs(currentPrice - openPrice) / g_pointValue) - GetCommissionInPoints();
   
   bool isAtBreakeven = (type == POSITION_TYPE_BUY && currentSL >= openPrice) ||
                       (type == POSITION_TYPE_SELL && currentSL <= openPrice);
                       
   if(!isAtBreakeven && pointsProfit >= BreakEven)
   {
      ModifyPosition(ticket, type, openPrice, commissionPoints);
   }
   else if(isAtBreakeven && pointsProfit >= TrailingStop)
   {
      TrailPosition(ticket, type, currentPrice, currentSL, commissionPoints);
   }
}

//+------------------------------------------------------------------+
//| Modify position stop loss                                         |
//+------------------------------------------------------------------+
void ModifyPosition(const ulong ticket, const ENUM_POSITION_TYPE type, 
                   const double openPrice, const double commissionPoints)
{
   double newSL = NormalizeDouble(openPrice + (type == POSITION_TYPE_BUY ? 
                 (g_pointValue + commissionPoints) : 
                 -(g_pointValue + commissionPoints)), g_digits);
                 
   trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
}

//+------------------------------------------------------------------+
//| Trail position stop loss                                          |
//+------------------------------------------------------------------+
void TrailPosition(const ulong ticket, const ENUM_POSITION_TYPE type,
                  const double currentPrice, const double currentSL,
                  const double commissionPoints)
{
   double newSL = NormalizeDouble(currentPrice - (type == POSITION_TYPE_BUY ?
                 (TrailingStop * g_pointValue + commissionPoints) : 
                 -(TrailingStop * g_pointValue + commissionPoints)), g_digits);
                 
   if((type == POSITION_TYPE_BUY && newSL > currentSL) ||
      (type == POSITION_TYPE_SELL && newSL < currentSL))
   {
      trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
   }
}

//+------------------------------------------------------------------+
//| Delete all pending orders                                         |
//+------------------------------------------------------------------+
void DeletePendingOrders()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      ulong ticket = OrderGetTicket(i);
      if(ticket <= 0) continue;
      
      if(OrderGetInteger(ORDER_MAGIC) == MagicNumber && 
         OrderGetString(ORDER_SYMBOL) == Symbol())
      {
         trade.OrderDelete(ticket);
      }
   }
}