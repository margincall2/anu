//+------------------------------------------------------------------+
//| Sakha Break V3 - Universal Pair Support                            |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Sakha"
#property link      "https://shopee.co.id/algotrade"
#property version   "3.00"
#property strict

//+------------------------------------------------------------------+
//| Input Parameters                                                   |
//+------------------------------------------------------------------+
// Trading Parameters
input ulong   MagicNumber    = 123456;          // Magic Number
input double  LotSize        = 0.1;             // Lot Size
input double  RiskPercent    = 1.0;             // Risk Percent (%)
input string  OrderComment   = "SakhaBreak_V3"; // Order Comment
input double  Commission     = 3.0;             // Commission per trade

// Risk Management Parameters
input int     StopLoss       = 50;              // Stop Loss (points)
input int     TakeProfit     = 100;             // Take Profit (points)
input int     TrailingStop   = 20;              // Trailing Stop (points)
input int     BreakEven      = 10;              // Break Even (points)
input int     MaxSpread      = 10;              // Max Allowed Spread (points)

// Timeframe Settings
input ENUM_TIMEFRAMES Timeframe         = PERIOD_CURRENT; // Trading Timeframe
input ENUM_TIMEFRAMES DonchianTimeframe = PERIOD_W1;     // Donchian Timeframe
input int             DonchianPeriod    = 20;            // Donchian Period

//+------------------------------------------------------------------+
//| Global Variables                                                   |
//+------------------------------------------------------------------+
datetime    g_lastBarTime    = 0;
double      g_pointValue     = 0.0;
double      g_adjustedPoint  = 0.0;
int         g_digits         = 0;
double      currentHigh, currentLow;

//+------------------------------------------------------------------+
//| Struct Definition                                                  |
//+------------------------------------------------------------------+
struct DonchianLevels 
{
   double upperBand;
   double lowerBand;
};

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   // Initialize symbol-specific values
   g_digits = (int)SymbolInfoInteger(Symbol(), SYMBOL_DIGITS);
   g_adjustedPoint = NormalizeDouble(SymbolInfoDouble(Symbol(), SYMBOL_POINT), g_digits);
   g_pointValue = (g_digits == 3 || g_digits == 5) ? g_adjustedPoint * 10.0 : g_adjustedPoint;
   
   Print("Symbol: ", Symbol());
   Print("Digits: ", g_digits);
   Print("Point: ", g_adjustedPoint);
   Print("Point Value: ", g_pointValue);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!CheckSpread()) return;

   if(IsNewBar())
   {
      UpdateLevels();
      ManagePendingOrders();
   }

   ManageOpenPositions();
}

//+------------------------------------------------------------------+
//| Trading Condition Functions                                        |
//+------------------------------------------------------------------+
bool CheckSpread()
{
   double currentSpread = SymbolInfoDouble(Symbol(), SYMBOL_ASK) - SymbolInfoDouble(Symbol(), SYMBOL_BID);
   double normalizedSpread = NormalizeDouble(currentSpread / g_pointValue, 1);
   
   if(normalizedSpread > MaxSpread)
   {
      DeletePendingOrders();
      return false;
   }
   return true;
}

//+------------------------------------------------------------------+
//| Bar Management                                                     |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   datetime currentBarTime = iTime(Symbol(), Timeframe, 0);
   if(currentBarTime != g_lastBarTime)
   {
      g_lastBarTime = currentBarTime;
      return true;
   }
   return false;
}

void UpdateLevels()
{
   currentHigh = NormalizeDouble(iHigh(Symbol(), Timeframe, 1), g_digits);
   currentLow = NormalizeDouble(iLow(Symbol(), Timeframe, 1), g_digits);
}

//+------------------------------------------------------------------+
//| Price Calculations                                                 |
//+------------------------------------------------------------------+
double GetCommissionInPoints()
{
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   if(tickValue <= 0) tickValue = 0.1;
   return NormalizeDouble(Commission / (LotSize * tickValue), 1);
}

//+------------------------------------------------------------------+
//| Donchian Channel Calculations                                      |
//+------------------------------------------------------------------+
DonchianLevels CalculateDonchianChannel()
{
   DonchianLevels levels;
   int barsToCount = DonchianPeriod;
   if(barsToCount <= 0) barsToCount = 20;
   int startBar = 1;

   double highestHigh = iHigh(Symbol(), DonchianTimeframe, iHighest(Symbol(), DonchianTimeframe, MODE_HIGH, barsToCount, startBar));
   double lowestLow = iLow(Symbol(), DonchianTimeframe, iLowest(Symbol(), DonchianTimeframe, MODE_LOW, barsToCount, startBar));
   
   levels.upperBand = NormalizeDouble(highestHigh, g_digits);
   levels.lowerBand = NormalizeDouble(lowestLow, g_digits);
   return levels;
}

//+------------------------------------------------------------------+
//| Order Management Functions                                         |
//+------------------------------------------------------------------+
void ManagePendingOrders()
{
   DonchianLevels levels = CalculateDonchianChannel();
   double commissionAdjustment = GetCommissionInPoints() * g_pointValue;
   
   double upperEntry = NormalizeDouble(levels.upperBand + commissionAdjustment, g_digits);
   double lowerEntry = NormalizeDouble(levels.lowerBand - commissionAdjustment, g_digits);
   
   bool buyExists = false, sellExists = false;
   
   // Check existing orders
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      ulong ticket = OrderGetTicket(i);
      if(!OrderSelect(ticket)) continue;
      
      if(OrderGetInteger(ORDER_MAGIC) == MagicNumber && 
         OrderGetString(ORDER_SYMBOL) == Symbol())
      {
         ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
         if(orderType == ORDER_TYPE_BUY_STOP) 
            CheckModifyOrder(ticket, currentHigh, ORDER_TYPE_BUY_STOP);
         else if(orderType == ORDER_TYPE_SELL_STOP) 
            CheckModifyOrder(ticket, currentLow, ORDER_TYPE_SELL_STOP);
      }
   }
   
   if(!buyExists && currentHigh > levels.upperBand) 
      PlacePendingOrder(ORDER_TYPE_BUY_STOP, currentHigh);
      
   if(!sellExists && currentLow < levels.lowerBand) 
      PlacePendingOrder(ORDER_TYPE_SELL_STOP, currentLow);
}

void CheckModifyOrder(ulong ticket, double newPrice, ENUM_ORDER_TYPE type)
{
   if(!OrderSelect(ticket)) return;
   double currentPrice = OrderGetDouble(ORDER_PRICE_OPEN);
   if(currentPrice == newPrice) return;

   double commissionPoints = GetCommissionInPoints() * g_pointValue;
   
   double sl = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(newPrice - (StopLoss * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(newPrice + (StopLoss * g_pointValue) + commissionPoints, g_digits);
   
   double tp = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(newPrice + (TakeProfit * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(newPrice - (TakeProfit * g_pointValue) + commissionPoints, g_digits);

   MqlTradeRequest request = {};
   MqlTradeResult result = {};

   request.action = TRADE_ACTION_MODIFY;
   request.order = ticket;
   request.price = NormalizeDouble(newPrice, g_digits);
   request.sl = sl;
   request.tp = tp;

   OrderSend(request, result);
}

void PlacePendingOrder(ENUM_ORDER_TYPE type, double price)
{
   double volume = CalculateLotSize();
   double commissionPoints = GetCommissionInPoints() * g_pointValue;
   
   double sl = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(price - (StopLoss * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(price + (StopLoss * g_pointValue) + commissionPoints, g_digits);
   
   double tp = (type == ORDER_TYPE_BUY_STOP) ?
               NormalizeDouble(price + (TakeProfit * g_pointValue) - commissionPoints, g_digits) :
               NormalizeDouble(price - (TakeProfit * g_pointValue) + commissionPoints, g_digits);

   MqlTradeRequest request = {};
   MqlTradeResult result = {};

   request.action = TRADE_ACTION_PENDING;
   request.symbol = Symbol();
   request.volume = volume;
   request.type = type;
   request.price = NormalizeDouble(price, g_digits);
   request.sl = sl;
   request.tp = tp;
   request.deviation = 5;
   request.magic = MagicNumber;
   request.comment = OrderComment;

   OrderSend(request, result);
}

//+------------------------------------------------------------------+
//| Position Management Functions                                      |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket <= 0) continue;
      
      if(PositionGetInteger(POSITION_MAGIC) == MagicNumber &&
         PositionGetString(POSITION_SYMBOL) == Symbol())
      {
         ManagePosition(ticket);
      }
   }
}

void ManagePosition(const ulong ticket)
{
   if(!PositionSelectByTicket(ticket)) return;
   
   ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   double currentPrice = (type == POSITION_TYPE_BUY) ? 
                        SymbolInfoDouble(Symbol(), SYMBOL_BID) : 
                        SymbolInfoDouble(Symbol(), SYMBOL_ASK);
                        
   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSL = PositionGetDouble(POSITION_SL);
   
   double commissionPoints = GetCommissionInPoints() * g_pointValue;
   double pointsProfit = (MathAbs(currentPrice - openPrice) / g_pointValue) - GetCommissionInPoints();
   
   bool isAtBreakeven = (type == POSITION_TYPE_BUY && currentSL >= openPrice) ||
                       (type == POSITION_TYPE_SELL && currentSL <= openPrice);
                       
   if(!isAtBreakeven && pointsProfit >= BreakEven)
   {
      double newSL = NormalizeDouble(openPrice + (type == POSITION_TYPE_BUY ? 
                    (g_pointValue + commissionPoints) : 
                    -(g_pointValue + commissionPoints)), g_digits);
      ModifyPositionSL(ticket, newSL);
   }
   else if(isAtBreakeven && pointsProfit >= TrailingStop)
   {
      double newSL = NormalizeDouble(currentPrice - (type == POSITION_TYPE_BUY ?
                    (TrailingStop * g_pointValue + commissionPoints) : 
                    -(TrailingStop * g_pointValue + commissionPoints)), g_digits);

      if((type == POSITION_TYPE_BUY && newSL > currentSL) ||
         (type == POSITION_TYPE_SELL && newSL < currentSL))
      {
         ModifyPositionSL(ticket, newSL);
      }
   }
}

void ModifyPositionSL(const ulong ticket, const double newSL)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};

   request.action = TRADE_ACTION_SLTP;
   request.position = ticket;
   request.symbol = Symbol();
   request.sl = newSL;
   request.tp = PositionGetDouble(POSITION_TP);

   OrderSend(request, result);
}

//+------------------------------------------------------------------+
//| Utility Functions                                                  |
//+------------------------------------------------------------------+
double CalculateLotSize()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   if(tickValue <= 0) tickValue = 0.1;

   double riskAmount = balance * RiskPercent / 100.0;
   double totalRisk = (StopLoss * tickValue) + Commission;
   double lotSize = NormalizeDouble(riskAmount / totalRisk, 2);

   double minLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);

   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   
   return lotSize;
}

void DeletePendingOrders()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      ulong ticket = OrderGetTicket(i);
      if(!OrderSelect(ticket)) continue;
      
      if(OrderGetInteger(ORDER_MAGIC) == MagicNumber && 
         OrderGetString(ORDER_SYMBOL) == Symbol())
      {
         MqlTradeRequest request = {};
         MqlTradeResult result = {};
         
         request.action = TRADE_ACTION_REMOVE;
         request.order = ticket;
         
         OrderSend(request, result);
      }
   }
}