//+------------------------------------------------------------------+
//| Sakha Property with Advanced Protection System                     |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Sakha"
#property link      "https://shopee.co.id/algotrade"
#property version   "3.00"
#property strict
#property description "SakhaBreak V3 - Advanced Trading System"

// Cache frequently used string constant
#define ORDER_COMMENT_CONST "SakhaBreak_DC"

//+------------------------------------------------------------------+
//| Forward Declarations                                              |
//+------------------------------------------------------------------+
bool ModifyPositionSl(const ulong ticket, const double newSl);
void HandleSmartTrailing(const ulong ticket, const ENUM_POSITION_TYPE type,
                        const double currentPrice, const double currentSl,
                        const double pointsProfit);
void HandleRegularTrailing(const ulong ticket, const ENUM_POSITION_TYPE type,
                          const double currentPrice, const double currentSl);
void CancelAllPending();
bool ClosePosition(const ulong ticket);
double CalculateVolatility();
bool CalculateDonchianChannels(const string symbol, const ENUM_TIMEFRAMES timeframe, 
                             const int period, double &upperBand, double &lowerBand);

//+------------------------------------------------------------------+
//| Structures Definition                                             |
//+------------------------------------------------------------------+
struct DonchianLevels 
{
    double upperBand;
    double lowerBand;
};

struct HiddenLevels 
{
    double realSL;
    double realTP;
    double fakeSL;
    double fakeTP;
};

struct TrailingState 
{
    bool isTrailingActive;
    double lastTrailingLevel;
    double highestProfit;
    double lowestProfit;
    datetime lastUpdate;
    double volatilityFactor;
    HiddenLevels levels;
};

//+------------------------------------------------------------------+
//| Global Variables and Objects                                      |
//+------------------------------------------------------------------+
MqlTradeRequest   request;
MqlTradeResult    result;
static TrailingState trailingStates[];
static DonchianLevels g_donchian;

// Cached values
static datetime lastBarTime = 0;
static double currentHigh = 0.0;
static double currentLow = 0.0;
static double tickValue = 0.0;
static double minLot = 0.0;
static double maxLot = 0.0;
static string currentSymbol = "";
static double pointValue = 0.0;
static double commissionPerLot = 0.0;

//+------------------------------------------------------------------+
//| Input Parameters                                                  |
//+------------------------------------------------------------------+
// Trading Parameters
input group "Basic Trading Settings"
input ulong   MagicNumber = 123456;          // Magic Number
input double  LotSize = 0.1;                 // Lot Size (Initial)
input double  RiskPercent = 1.0;             // Risk per trade (%)
input string  OrderComment = ORDER_COMMENT_CONST; // Order Comment
input double  Commission = 3.0;              // Commission per trade

// Risk Management Parameters
input group "Risk Management"
input int     StopLoss = 50;                 // Stop Loss (points)
input int     TakeProfit = 100;              // Take Profit (points)
input int     TrailingStop = 20;             // Trailing Stop (points)
input int     BreakEven = 10;                // Break Even (points)
input int     MaxSpread = 10;                // Max Allowed Spread
input int     MaxPositions = 1;              // Maximum Positions Allowed
input bool    UseATRFilter = true;           // Use ATR Filter
input int     ATRPeriod = 14;               // ATR Period
input double  ATRMultiplier = 1.5;          // ATR Multiplier

// Virtual Protection Settings
input group "Virtual Protection Settings"
input bool    UseVirtualSLTP = true;         // Gunakan Virtual SL/TP
input int     VirtualDistance = 30;          // Jarak Virtual SL/TP (points)
input bool    UseRandomOffset = true;        // Gunakan Random Offset
input int     MaxRandomPoints = 5;           // Maksimum Random Points
input bool    UseHiddenTP = true;           // Hide Take Profit Level
input bool    UseHiddenSL = true;           // Hide Stop Loss Level

// Smart Trailing Settings
input group "Smart Trailing Settings"
input bool    UseSmartTrailing = true;       // Gunakan Smart Trailing
input bool    UseVolatilityTrailing = true;  // Trailing berdasar Volatilitas
input int     TrailingStartPoints = 50;      // Jarak Profit sebelum Trailing
input double  TrailingRatio = 2.0;           // Rasio Trailing
input int     MinimumTrailingStep = 5;       // Minimum Trailing Step
input double  VolatilityMultiplier = 1.0;    // Volatility Multiplier

// Timeframe Settings
input group "Timeframe Settings"
input ENUM_TIMEFRAMES Timeframe = PERIOD_CURRENT;      // Trading Timeframe
input ENUM_TIMEFRAMES DonchianTimeframe = PERIOD_H1;   // Donchian Timeframe
input int             DonchianPeriod = 20;            // Donchian Period
input bool           UseMultiTimeframe = false;       // Use Multi Timeframe Analysis
//+------------------------------------------------------------------+
//| Helper Functions                                                  |
//+------------------------------------------------------------------+
bool CalculateDonchianChannels(const string symbol, const ENUM_TIMEFRAMES timeframe, 
                             const int period, double &upperBand, double &lowerBand)
{
    double highArray[], lowArray[];
    ArraySetAsSeries(highArray, true);
    ArraySetAsSeries(lowArray, true);
    
    // Allocate arrays with proper size
    if(ArrayResize(highArray, period) != period || ArrayResize(lowArray, period) != period)
    {
        Print("Failed to allocate arrays for Donchian calculation");
        return false;
    }
    
    // Copy price data
    int copied = CopyHigh(symbol, timeframe, 0, period, highArray);
    if(copied != period)
    {
        Print("Error copying high prices, copied=", copied, " error=", GetLastError());
        return false;
    }
    
    copied = CopyLow(symbol, timeframe, 0, period, lowArray);
    if(copied != period)
    {
        Print("Error copying low prices, copied=", copied, " error=", GetLastError());
        return false;
    }
    
    // Calculate highest high and lowest low
    upperBand = highArray[ArrayMaximum(highArray, 0, period)];
    lowerBand = lowArray[ArrayMinimum(lowArray, 0, period)];
    
    return true;
}

//+------------------------------------------------------------------+
//| Calculate Hidden Levels Function                                   |
//+------------------------------------------------------------------+
HiddenLevels CalculateHiddenLevels(const double price, const ENUM_ORDER_TYPE type)
{
    HiddenLevels levels;
    
    double direction = (type == ORDER_TYPE_BUY_STOP || type == ORDER_TYPE_BUY_LIMIT) ? 1.0 : -1.0;
    
    // Calculate real SL/TP
    levels.realSL = price - direction * StopLoss * pointValue;
    levels.realTP = price + direction * TakeProfit * pointValue;
    
    // Calculate fake SL/TP with virtual distance
    if(UseVirtualSLTP)
    {
        double randomOffset = UseRandomOffset ? 
                            MathRand() % MaxRandomPoints * pointValue : 0;
                            
        levels.fakeSL = levels.realSL + (direction * VirtualDistance * pointValue) + randomOffset;
        levels.fakeTP = levels.realTP - (direction * VirtualDistance * pointValue) + randomOffset;
    }
    else
    {
        levels.fakeSL = levels.realSL;
        levels.fakeTP = levels.realTP;
    }
    
    return levels;
}

//+------------------------------------------------------------------+
//| Order Management Functions                                        |
//+------------------------------------------------------------------+
bool PlacePendingOrder(const ENUM_ORDER_TYPE type, const double price)
{
    if(price <= 0)
    {
        Print("Invalid price for pending order");
        return false;
    }

    double spread = SymbolInfoDouble(currentSymbol, SYMBOL_ASK) - SymbolInfoDouble(currentSymbol, SYMBOL_BID);
    if(spread > MaxSpread * pointValue)
    {
        Print("Spread too high: ", spread, " > ", MaxSpread * pointValue);
        return false;
    }

    HiddenLevels levels = CalculateHiddenLevels(price, type);
    
    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_PENDING;
    request.symbol = currentSymbol;
    request.volume = CalculateLotSize();
    request.type = type;
    request.price = price;
    request.sl = levels.fakeSL;
    request.tp = levels.fakeTP;
    request.deviation = 5;
    request.magic = MagicNumber;
    request.comment = OrderComment;

    Print("Placing order: Type=", type, " Price=", price, " SL=", levels.fakeSL, " TP=", levels.fakeTP);

    if(!OrderSend(request, result)) 
    {
        Print("OrderSend error: ", GetLastError());
        return false;
    }
    
    if(result.retcode != TRADE_RETCODE_DONE)
    {
        Print("Order placement failed with retcode: ", result.retcode);
        return false;
    }
    
    trailingStates[result.order].levels = levels;
    return true;
}

//+------------------------------------------------------------------+
//| Manage Pending Orders                                             |
//+------------------------------------------------------------------+
void ManagePendingOrders(const DonchianLevels &donchian)
{
    if(donchian.upperBand <= 0 || donchian.lowerBand <= 0)
    {
        Print("Invalid Donchian values");
        return;
    }

    Print("Managing Pending Orders - Upper:", donchian.upperBand, " Lower:", donchian.lowerBand);
    
    const double effectiveUpperBand = donchian.upperBand + commissionPerLot * pointValue;
    const double effectiveLowerBand = donchian.lowerBand - commissionPerLot * pointValue;
    
    // Get current candle values
    const double bodyHigh = MathMax(iOpen(currentSymbol, Timeframe, 0), iClose(currentSymbol, Timeframe, 0));
    const double bodyLow = MathMin(iOpen(currentSymbol, Timeframe, 0), iClose(currentSymbol, Timeframe, 0));
    const double currentPrice = SymbolInfoDouble(currentSymbol, SYMBOL_ASK);

    if(bodyHigh <= 0 || bodyLow <= 0)
    {
        Print("Invalid price levels for pending orders");
        return;
    }

    // Check spread
    double spread = SymbolInfoDouble(currentSymbol, SYMBOL_ASK) - SymbolInfoDouble(currentSymbol, SYMBOL_BID);
    if(spread > MaxSpread * pointValue)
    {
        Print("Spread too high: ", spread, " > ", MaxSpread * pointValue);
        return;
    }

    bool buyStopExists = false, sellStopExists = false;
    ulong buyTicket = 0, sellTicket = 0;

    // Check existing orders
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == MagicNumber)
        {
            ENUM_ORDER_TYPE type = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if(type == ORDER_TYPE_BUY_STOP)
            {
                buyStopExists = true;
                buyTicket = ticket;
            }
            else if(type == ORDER_TYPE_SELL_STOP)
            {
                sellStopExists = true;
                sellTicket = ticket;
            }
        }
    }

    // Add more detailed logging
    Print("Price analysis - Current:", currentPrice, 
          " UpperBand:", effectiveUpperBand,
          " LowerBand:", effectiveLowerBand,
          " BodyHigh:", bodyHigh,
          " BodyLow:", bodyLow);

    // Modified order placement logic
    if(currentPrice > effectiveUpperBand)
    {
        Print("Price above Upper Band - Placing orders");
        if(!buyStopExists && PositionsTotal() < MaxPositions) 
        {
            double entryPrice = bodyHigh + (5 * pointValue); // Add small buffer
            Print("Placing Buy Stop at:", entryPrice);
            PlacePendingOrder(ORDER_TYPE_BUY_STOP, entryPrice);
        }
    }
    else if(currentPrice < effectiveLowerBand)
    {
        Print("Price below Lower Band - Placing orders");
        if(!sellStopExists && PositionsTotal() < MaxPositions) 
        {
            double entryPrice = bodyLow - (5 * pointValue); // Add small buffer
            Print("Placing Sell Stop at:", entryPrice);
            PlacePendingOrder(ORDER_TYPE_SELL_STOP, entryPrice);
        }
    }
    else
    {
        // Only cancel orders if price is back inside the bands
        CancelAllPending();
    }
}
//+------------------------------------------------------------------+
//| Position Management Functions                                      |
//+------------------------------------------------------------------+
void ManageOpenPositions()
{
    if(PositionsTotal() <= 0) return;

    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && 
           PositionGetInteger(POSITION_MAGIC) == MagicNumber)
        {
            ManagePosition(ticket);
        }
    }
}

void ManagePosition(const ulong ticket)
{
    if(!PositionSelectByTicket(ticket)) return;

    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double currentPrice = (type == POSITION_TYPE_BUY) ? 
                         SymbolInfoDouble(currentSymbol, SYMBOL_BID) :
                         SymbolInfoDouble(currentSymbol, SYMBOL_ASK);
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentSl = PositionGetDouble(POSITION_SL);
    
    // Check Virtual SL/TP
    if(UseVirtualSLTP)
    {
        HiddenLevels levels = trailingStates[ticket].levels;
        if((type == POSITION_TYPE_BUY && currentPrice <= levels.realSL) ||
           (type == POSITION_TYPE_SELL && currentPrice >= levels.realSL))
        {
            Print("Virtual SL hit - Closing position");
            ClosePosition(ticket);
            return;
        }
        
        if((type == POSITION_TYPE_BUY && currentPrice >= levels.realTP) ||
           (type == POSITION_TYPE_SELL && currentPrice <= levels.realTP))
        {
            Print("Virtual TP hit - Closing position");
            ClosePosition(ticket);
            return;
        }
    }

    double pointsProfit = (MathAbs(currentPrice - openPrice) / pointValue) - commissionPerLot;
    bool isAtBreakeven = (type == POSITION_TYPE_BUY && currentSl >= openPrice) ||
                        (type == POSITION_TYPE_SELL && currentSl <= openPrice);

    // Break Even Logic
    if(!isAtBreakeven && pointsProfit >= BreakEven)
    {
        double newSl = openPrice + (type == POSITION_TYPE_BUY ?
                      (1 + commissionPerLot) * pointValue :
                      (-1 - commissionPerLot) * pointValue);
                      
        if(UseVirtualSLTP)
        {
            trailingStates[ticket].levels.realSL = newSl;
            newSl = (type == POSITION_TYPE_BUY) ?
                    newSl - VirtualDistance * pointValue :
                    newSl + VirtualDistance * pointValue;
        }
        
        Print("Moving to breakeven - New SL:", newSl);
        
        if(ModifyPositionSl(ticket, newSl))
        {
            if(UseSmartTrailing)
            {
                trailingStates[ticket].isTrailingActive = false;
                trailingStates[ticket].lastTrailingLevel = 0.0;
            }
            return;
        }
    }

    // Trailing Logic
    if(isAtBreakeven && pointsProfit >= TrailingStartPoints)
    {
        if(UseSmartTrailing)
            HandleSmartTrailing(ticket, type, currentPrice, currentSl, pointsProfit);
        else
            HandleRegularTrailing(ticket, type, currentPrice, currentSl);
    }
}

//+------------------------------------------------------------------+
//| Trailing Functions                                                |
//+------------------------------------------------------------------+
double CalculateVolatility()
{
    double atr[];
    ArraySetAsSeries(atr, true);
    
    int atrHandle = iATR(currentSymbol, PERIOD_CURRENT, ATRPeriod);
    if(atrHandle == INVALID_HANDLE)
    {
        Print("Failed to create ATR indicator handle");
        return 1.0;
    }
    
    if(CopyBuffer(atrHandle, 0, 0, ATRPeriod, atr) != ATRPeriod)
    {
        Print("Failed to copy ATR data");
        IndicatorRelease(atrHandle);
        return 1.0;
    }
    
    double currentATR = atr[0];
    double averageATR = 0;
    
    for(int i = 0; i < ATRPeriod; i++)
    {
        averageATR += atr[i];
    }
    averageATR /= ATRPeriod;
    
    IndicatorRelease(atrHandle);
    
    if(averageATR == 0) return 1.0;
    return currentATR / averageATR;
}

void HandleSmartTrailing(const ulong ticket, const ENUM_POSITION_TYPE type,
                        const double currentPrice, const double currentSl,
                        const double pointsProfit)
{
    TrailingState state = trailingStates[ticket];
    
    if(!state.isTrailingActive)
    {
        state.isTrailingActive = true;
        state.lastTrailingLevel = currentSl;
        state.highestProfit = pointsProfit;
        state.lowestProfit = pointsProfit;
        state.lastUpdate = TimeCurrent();
        state.volatilityFactor = UseVolatilityTrailing ? CalculateVolatility() : 1.0;
    }

    state.highestProfit = MathMax(state.highestProfit, pointsProfit);
    state.lowestProfit = MathMin(state.lowestProfit, pointsProfit);

    double trailingStep = UseVolatilityTrailing ? 
                         TrailingStop * state.volatilityFactor :
                         TrailingStop;
    
    trailingStep = MathMax(trailingStep, MinimumTrailingStep);
    double trailingDistance = trailingStep * TrailingRatio;

    double realNewSL = currentPrice - (type == POSITION_TYPE_BUY ?
                      (trailingDistance + commissionPerLot) * pointValue :
                      -(trailingDistance + commissionPerLot) * pointValue);

    double fakeNewSL = UseVirtualSLTP ? (type == POSITION_TYPE_BUY ?
                      realNewSL - VirtualDistance * pointValue :
                      realNewSL + VirtualDistance * pointValue) : realNewSL;

    if((type == POSITION_TYPE_BUY && realNewSL > state.levels.realSL) ||
       (type == POSITION_TYPE_SELL && realNewSL < state.levels.realSL))
    {
        Print("Smart Trailing - Updating SL to:", fakeNewSL);
        
        if(ModifyPositionSl(ticket, fakeNewSL))
        {
            state.levels.realSL = realNewSL;
            state.lastTrailingLevel = fakeNewSL;
            trailingStates[ticket] = state;
        }
    }

    if(UseVolatilityTrailing && TimeCurrent() - state.lastUpdate >= 300)
    {
        state.volatilityFactor = CalculateVolatility();
        state.lastUpdate = TimeCurrent();
        trailingStates[ticket] = state;
    }
}
void HandleRegularTrailing(const ulong ticket, const ENUM_POSITION_TYPE type,
                         const double currentPrice, const double currentSl)
{
    double newSl = currentPrice - (type == POSITION_TYPE_BUY ?
                   (TrailingStop + commissionPerLot) * pointValue :
                   -(TrailingStop + commissionPerLot) * pointValue);

    if((type == POSITION_TYPE_BUY && newSl > currentSl) ||
       (type == POSITION_TYPE_SELL && newSl < currentSl))
    {
        Print("Regular Trailing - Updating SL to:", newSl);
        ModifyPositionSl(ticket, newSl);
    }
}

//+------------------------------------------------------------------+
//| Utility Functions                                                 |
//+------------------------------------------------------------------+
bool ModifyPositionSl(const ulong ticket, const double newSl)
{
    if(!PositionSelectByTicket(ticket)) return false;

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol = currentSymbol;
    request.sl = newSl;
    request.tp = PositionGetDouble(POSITION_TP);

    return OrderSend(request, result);
}

double CalculateLotSize()
{
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk = balance * RiskPercent / 100.0;
    double tickRisk = StopLoss * tickValue + Commission;
    double lotSize = NormalizeDouble(risk / tickRisk, 2);
    
    return MathMin(MathMax(lotSize, minLot), maxLot);
}

bool ClosePosition(const ulong ticket)
{
    if(!PositionSelectByTicket(ticket)) return false;

    ZeroMemory(request);
    ZeroMemory(result);

    request.action = TRADE_ACTION_DEAL;
    request.position = ticket;
    request.symbol = currentSymbol;
    request.volume = PositionGetDouble(POSITION_VOLUME);
    request.type = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? 
                  ORDER_TYPE_SELL : ORDER_TYPE_BUY;
    request.price = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ?
                   SymbolInfoDouble(currentSymbol, SYMBOL_BID) :
                   SymbolInfoDouble(currentSymbol, SYMBOL_ASK);
    request.deviation = 5;

    return OrderSend(request, result);
}

void CancelAllPending()
{
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == MagicNumber)
        {
            ZeroMemory(request);
            ZeroMemory(result);
            
            request.action = TRADE_ACTION_REMOVE;
            request.order = ticket;
            
            if(!OrderSend(request, result))
            {
                Print("Error canceling order ", ticket, ": ", GetLastError());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Expert Initialization Function                                    |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize arrays first
    ArrayResize(trailingStates, 1000); // Pre-allocate space for trailing states
    
    // Initialize each element manually instead of using ArrayInitialize
    for(int i = 0; i < ArraySize(trailingStates); i++)
    {
        trailingStates[i].isTrailingActive = false;
        trailingStates[i].lastTrailingLevel = 0.0;
        trailingStates[i].highestProfit = 0.0;
        trailingStates[i].lowestProfit = 0.0;
        trailingStates[i].lastUpdate = 0;
        trailingStates[i].volatilityFactor = 1.0;
        trailingStates[i].levels.realSL = 0.0;
        trailingStates[i].levels.realTP = 0.0;
        trailingStates[i].levels.fakeSL = 0.0;
        trailingStates[i].levels.fakeTP = 0.0;
    }
    
    // Initialize symbol-specific values
    currentSymbol = Symbol();
    pointValue = SymbolInfoDouble(currentSymbol, SYMBOL_POINT);
    tickValue = SymbolInfoDouble(currentSymbol, SYMBOL_TRADE_TICK_VALUE);
    minLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MIN);
    maxLot = SymbolInfoDouble(currentSymbol, SYMBOL_VOLUME_MAX);
    commissionPerLot = Commission;
    
    // Validate timeframe inputs using local variable
    ENUM_TIMEFRAMES useTimeframe = DonchianTimeframe;
    if(useTimeframe == PERIOD_CURRENT)
        useTimeframe = Period();
        
    // Add validation
    if(DonchianPeriod <= 0)
    {
        Print("Invalid DonchianPeriod value");
        return INIT_PARAMETERS_INCORRECT;
    }
    
    Print("Expert initialized with Symbol:", currentSymbol);
    Print("Point Value:", pointValue, " Tick Value:", tickValue);
    Print("Min Lot:", minLot, " Max Lot:", maxLot);
    Print("Donchian Settings - Timeframe:", EnumToString(useTimeframe), " Period:", DonchianPeriod);

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert Deinitialization Function                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    ArrayFree(trailingStates);
}

//+------------------------------------------------------------------+
//| Expert Tick Function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Update current price data
    currentHigh = iHigh(currentSymbol, Timeframe, 0);
    currentLow = iLow(currentSymbol, Timeframe, 0);

    // Check for new bar
    datetime currentBarTime = iTime(currentSymbol, Timeframe, 0);
    bool isNewBar = (currentBarTime != lastBarTime);
    lastBarTime = currentBarTime;

    if(isNewBar)
    {
        // Calculate Donchian Channels with error checking
        if(!CalculateDonchianChannels(currentSymbol, DonchianTimeframe, 
                                    DonchianPeriod, g_donchian.upperBand, g_donchian.lowerBand))
        {
            Print("Failed to calculate Donchian Channels, skipping this tick");
            return;
        }
        
        Print("New Bar - Donchian Bands Updated - Upper:", g_donchian.upperBand, 
              " Lower:", g_donchian.lowerBand,
              " Current High:", currentHigh,
              " Current Low:", currentLow);
    }

    // Manage positions and orders
    ManageOpenPositions();
    ManagePendingOrders(g_donchian);
}

//+------------------------------------------------------------------+
//| Expert Tester Function                                           |
//+------------------------------------------------------------------+
double OnTester()
{
    return 0.0;
}